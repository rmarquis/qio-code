Index: code/api/cvarAPI.h
===================================================================
--- code/api/cvarAPI.h	(revision 183)
+++ code/api/cvarAPI.h	(working copy)
@@ -32,7 +32,7 @@
 
 // these are only temporary function pointers, TODO: rework them?
 struct cvarsAPI_s : public iFaceBase_i {
-	void (*Cvar_Register)( vmCvar_t *cvar, const char *var_name, const char *value, int flags );
+	void (*Cvar_Register)( struct vmCvar_t *cvar, const char *var_name, const char *value, int flags );
 	void (*Cvar_Update)( vmCvar_t *cvar );
 	void (*Cvar_Set)( const char *var_name, const char *value );
 	int	(*Cvar_VariableIntegerValue)( const char *var_name );
Index: code/api/vfsAPI.h
===================================================================
--- code/api/vfsAPI.h	(revision 296)
+++ code/api/vfsAPI.h	(working copy)
@@ -27,29 +27,45 @@
 #define __VFSAPI_H__
 
 #include "iFaceBase.h"
-#include <qcommon/q_shared.h> // for filehandle
+#include <api/readStreamAPI.h>
 
-#define VFS_API_IDENTSTR "VFSAPI0001"
-
-// these are only temporary function pointers, TODO: rework them?
-struct vfsAPI_s : public iFaceBase_i {
-	int (*FS_FOpenFile)( const char *qpath, fileHandle_t *f, fsMode_t mode );
-	int (*FS_Read)( void *buffer, int len, fileHandle_t f );
-	int (*FS_Write)( const void *buffer, int len, fileHandle_t f );
-	void (*FS_FCloseFile)( fileHandle_t f );
-	int (*FS_GetFileList)( const char *path, const char *extension, char *listbuf, int bufsize );
-	int (*FS_Seek)( fileHandle_t f, long offset, int origin ); // fsOrigin_t
-	char **	(*FS_ListFiles)( const char *name, const char *extension, int *numfilesfound );
-	void	(*FS_FreeFileList)( char **filelist );
-	long (*FS_ReadFile)(const char *qpath, void **buffer);
-	void (*FS_FreeFile)( void *buffer );
-	bool FS_FileExists(const char *fname) {
-		if(FS_ReadFile(fname,0) > 0)
-			return true;
-		return false;
-	}
+#define VFS_API_IDENTSTR "VFSAPI0002"
+
+class vfsFileAPI_i : public readStreamAPI_i {
+public:
+	virtual const char *getName() const = 0;
+
+//	virtual u32 readData(void *out, u32 numBytes) = 0;
+
+	virtual void forceFlush() = 0;
+
+	virtual u32 writeData(const void *buf, u32 numBytes) = 0;
+
 };
+class vfsFileListAPI_i {
+public:
+	virtual u32 getNumFiles() const = 0;
+	virtual const char *getFileName(u32 fileIndex) const = 0;
+};
+
+class vfsAPI_i : public iFaceBase_i {
+public:
+	virtual void init() = 0;
+	virtual void shutdown() = 0;
+
+	// raw file data loading (*bufPtr will be mallocated by VFS and must be fried later)
+	virtual u32 loadFileData(const char *fname, byte **bufPtr) = 0;
+	virtual void freeFileData(byte **bufPtr) = 0;
+
+	virtual class vfsFileListAPI_i *listFiles(const char *dir, const char *ext) = 0;
+	virtual void freeFileList(class vfsFileListAPI_i *list) = 0;
+
+	virtual vfsFileAPI_i *openFile(const char *fname, const char *type) = 0;
+	virtual void closeFile(vfsFileAPI_i *f) = 0;
+
+	virtual bool fileExists(const char *fname) const = 0;
+};
 
-extern vfsAPI_s *g_vfs;
+extern vfsAPI_i *g_vfs;
 
 #endif // __VFSAPI_H__
Index: code/cgame/cg_api.cpp
===================================================================
--- code/cgame/cg_api.cpp	(revision 217)
+++ code/cgame/cg_api.cpp	(working copy)
@@ -41,7 +41,7 @@
 class iFaceMgrAPI_i *g_iFaceMan = 0;
 // imports
 clAPI_s *g_client = 0;
-vfsAPI_s *g_vfs = 0;
+vfsAPI_i *g_vfs = 0;
 cvarsAPI_s *g_cvars = 0;
 coreAPI_s *g_core = 0;
 rAPI_i *rf = 0;
Index: code/cgame/cg_local.h
===================================================================
--- code/cgame/cg_local.h	(revision 277)
+++ code/cgame/cg_local.h	(working copy)
@@ -173,7 +173,7 @@
 	//
 	class rModelAPI_i	*gameModels[MAX_MODELS];
 	class cMod_i		*gameCollModels[MAX_MODELS];
-	sfxHandle_t		gameSounds[MAX_SOUNDS];
+	int		gameSounds[MAX_SOUNDS];
 	const class skelAnimAPI_i	*gameAnims[MAX_ANIMATIONS];
 //	str gameAnimNames[MAX_ANIMATIONS];
 	const class afDeclAPI_i	*gameAFs[MAX_RAGDOLLDEFS];
Index: code/cgame/cg_servercmds.cpp
===================================================================
--- code/cgame/cg_servercmds.cpp	(revision 275)
+++ code/cgame/cg_servercmds.cpp	(working copy)
@@ -51,13 +51,13 @@
 	mapname = Info_ValueForKey( info, "mapname" );
 	// fix and format the world map name
 	Com_sprintf( cgs.mapname, sizeof( cgs.mapname ), "maps/%s.bsp", mapname );
-	if(g_vfs->FS_FileExists(cgs.mapname) == false) {
+	if(g_vfs->fileExists(cgs.mapname) == false) {
 		// if there is no .bsp file, fall back to .proc (Doom3 .bsp tree with portals but without PVS)
 		Com_sprintf( cgs.mapname, sizeof( cgs.mapname ), "maps/%s.proc", mapname );
-		if(g_vfs->FS_FileExists(cgs.mapname) == false) {	
+		if(g_vfs->fileExists(cgs.mapname) == false) {	
 			// check for ET:QW proc binary
 			Com_sprintf( cgs.mapname, sizeof( cgs.mapname ), "maps/%s.procb", mapname );
-			if(g_vfs->FS_FileExists(cgs.mapname) == false) {
+			if(g_vfs->fileExists(cgs.mapname) == false) {
 				// and finally, if there is no .proc file fall back to .map
 				// (NOTE: .bsp files are a compiled .map files with some extra info
 				// like lightmaps, lightgrid, PVS, etc...)
Index: code/client/cl_avi.cpp
===================================================================
--- code/client/cl_avi.cpp	(revision 183)
+++ code/client/cl_avi.cpp	(working copy)
@@ -41,13 +41,13 @@
 typedef struct aviFileData_s
 {
   qboolean      fileOpen;
-  fileHandle_t  f;
+  vfsFileAPI_i *  f;
   char          fileName[ MAX_QPATH ];
   int           fileSize;
   int           moviOffset;
   int           moviSize;
 
-  fileHandle_t  idxF;
+  vfsFileAPI_i *  idxF;
   int           numIndices;
 
   int           frameRate;
@@ -79,7 +79,7 @@
 SafeFS_Write
 ===============
 */
-static ID_INLINE void SafeFS_Write( const void *buffer, int len, fileHandle_t f )
+static ID_INLINE void SafeFS_Write( const void *buffer, int len, vfsFileAPI_i * f )
 {
   if( FS_Write( buffer, len, f ) < len )
     Com_Error( ERR_DROP, "Failed to write avi file" );
Index: code/client/cl_cin.cpp
===================================================================
--- code/client/cl_cin.cpp	(revision 183)
+++ code/client/cl_cin.cpp	(working copy)
@@ -91,7 +91,7 @@
 	int					CIN_WIDTH, CIN_HEIGHT;
 	int					xpos, ypos, width, height;
 	qboolean			looping, holdAtEnd, dirty, alterGameState, silent, shader;
-	fileHandle_t		iFile;
+	vfsFileAPI_i *		iFile;
 	e_status			status;
 	unsigned int		startTime;
 	unsigned int		lastTime;
Index: code/client/cl_console.cpp
===================================================================
--- code/client/cl_console.cpp	(revision 183)
+++ code/client/cl_console.cpp	(working copy)
@@ -137,7 +137,7 @@
 {
 	int		l, x, i;
 	short	*line;
-	fileHandle_t	f;
+	vfsFileAPI_i *	f;
 	char	buffer[1024];
 
 	if (Cmd_Argc() != 2)
Index: code/client/cl_curl.cpp
===================================================================
--- code/client/cl_curl.cpp	(revision 225)
+++ code/client/cl_curl.cpp	(working copy)
@@ -205,7 +205,7 @@
 static size_t CL_cURL_CallbackWrite(void *buffer, size_t size, size_t nmemb,
 	void *stream)
 {
-	FS_Write( buffer, size*nmemb, ((fileHandle_t*)stream)[0] );
+	FS_Write( buffer, size*nmemb, ((vfsFileAPI_i **)stream)[0] );
 	return size*nmemb;
 }
 
Index: code/client/cl_keys.cpp
===================================================================
--- code/client/cl_keys.cpp	(revision 183)
+++ code/client/cl_keys.cpp	(working copy)
@@ -1018,7 +1018,7 @@
 Writes lines containing "bind key value"
 ============
 */
-void Key_WriteBindings( fileHandle_t f ) {
+void Key_WriteBindings( vfsFileAPI_i * f ) {
 	int		i;
 
 	FS_Printf (f, "unbindall\n" );
@@ -1406,7 +1406,7 @@
 {
 	char					*token, *text_p;
 	int						i, numChars, numLines = 0;
-	fileHandle_t	f;
+	vfsFileAPI_i *	f;
 
 	consoleSaveBufferSize = FS_FOpenFileRead( CONSOLE_HISTORY_FILE, &f, qfalse );
 	if( !f )
@@ -1475,7 +1475,7 @@
 {
 	int						i;
 	int						lineLength, saveBufferLength, additionalLength;
-	fileHandle_t	f;
+	vfsFileAPI_i *	f;
 
 	consoleSaveBuffer[ 0 ] = '\0';
 
Index: code/client/cl_main.cpp
===================================================================
--- code/client/cl_main.cpp	(revision 284)
+++ code/client/cl_main.cpp	(working copy)
@@ -670,7 +670,7 @@
 #endif
 				Com_sprintf(name, sizeof(name), "demos/%s.%s%d", demoName, DEMOEXT, com_protocol->integer);
 
-			if (!FS_FileExists(name))
+			if (!fileExists(name))
 				break;	// file doesn't exist
 		}
 	}
@@ -824,7 +824,7 @@
 			{
 				int i;
 				int numFrames;
-				fileHandle_t f;
+				vfsFileAPI_i * f;
 
 				if( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )
 					numFrames = MAX_TIMEDEMO_DURATIONS;
@@ -1268,7 +1268,7 @@
 */
 static void CL_UpdateGUID( const char *prefix, int prefix_len )
 {
-	fileHandle_t f;
+	vfsFileAPI_i * f;
 	int len;
 
 	len = FS_SV_FOpenFileRead( QKEY_FILE, &f );
@@ -3100,7 +3100,7 @@
       Com_sprintf( filename, MAX_OSPATH, "videos/video%d%d%d%d.avi",
           a, b, c, d );
 
-      if( !FS_FileExists( filename ) )
+      if( !fileExists( filename ) )
         break; // file doesn't exist
     }
 
@@ -3141,7 +3141,7 @@
 {
 	int len = 0;
 	unsigned char buff[ QKEY_SIZE ];
-	fileHandle_t f;
+	vfsFileAPI_i * f;
 
 	len = FS_SV_FOpenFileRead( QKEY_FILE, &f );
 	FS_FCloseFile( f );
Index: code/client/cl_parse.cpp
===================================================================
--- code/client/cl_parse.cpp	(revision 183)
+++ code/client/cl_parse.cpp	(working copy)
@@ -383,13 +383,13 @@
 	}
 
 	// check pure server string
-	s = Info_ValueForKey( systemInfo, "sv_paks" );
-	t = Info_ValueForKey( systemInfo, "sv_pakNames" );
-	FS_PureServerSetLoadedPaks( s, t );
+//	s = Info_ValueForKey( systemInfo, "sv_paks" );
+//	t = Info_ValueForKey( systemInfo, "sv_pakNames" );
+//	FS_PureServerSetLoadedPaks( s, t );
 
-	s = Info_ValueForKey( systemInfo, "sv_referencedPaks" );
-	t = Info_ValueForKey( systemInfo, "sv_referencedPakNames" );
-	FS_PureServerSetReferencedPaks( s, t );
+//	s = Info_ValueForKey( systemInfo, "sv_referencedPaks" );
+//	t = Info_ValueForKey( systemInfo, "sv_referencedPakNames" );
+//	FS_PureServerSetReferencedPaks( s, t );
 
 	gameSet = qfalse;
 	// scan through all the variables in the systeminfo and locally set cvars to match
@@ -548,7 +548,7 @@
 		Q_strncpyz(cls.oldGame, oldGame, sizeof(cls.oldGame));
 	}
 
-	FS_ConditionalRestart(clc.checksumFeed, qfalse);
+//	FS_ConditionalRestart(clc.checksumFeed, qfalse);
 
 	// This used to call CL_StartHunkUsers, but now we enter the download state before loading the
 	// cgame
@@ -569,92 +569,92 @@
 =====================
 */
 void CL_ParseDownload ( msg_t *msg ) {
-	int		size;
-	unsigned char data[MAX_MSGLEN];
-	uint16_t block;
+	//int		size;
+	//unsigned char data[MAX_MSGLEN];
+	//uint16_t block;
 
-	if (!*clc.downloadTempName) {
-		Com_Printf("Server sending download, but no download was requested\n");
-		CL_AddReliableCommand("stopdl", qfalse);
-		return;
-	}
+	//if (!*clc.downloadTempName) {
+	//	Com_Printf("Server sending download, but no download was requested\n");
+	//	CL_AddReliableCommand("stopdl", qfalse);
+	//	return;
+	//}
 
-	// read the data
-	block = MSG_ReadShort ( msg );
+	//// read the data
+	//block = MSG_ReadShort ( msg );
 
-	if(!block && !clc.downloadBlock)
-	{
-		// block zero is special, contains file size
-		clc.downloadSize = MSG_ReadLong ( msg );
+	//if(!block && !clc.downloadBlock)
+	//{
+	//	// block zero is special, contains file size
+	//	clc.downloadSize = MSG_ReadLong ( msg );
 
-		Cvar_SetValue( "cl_downloadSize", clc.downloadSize );
+	//	Cvar_SetValue( "cl_downloadSize", clc.downloadSize );
 
-		if (clc.downloadSize < 0)
-		{
-			Com_Error( ERR_DROP, "%s", MSG_ReadString( msg ) );
-			return;
-		}
-	}
+	//	if (clc.downloadSize < 0)
+	//	{
+	//		Com_Error( ERR_DROP, "%s", MSG_ReadString( msg ) );
+	//		return;
+	//	}
+	//}
 
-	size = MSG_ReadShort ( msg );
-	if (size < 0 || size > sizeof(data))
-	{
-		Com_Error(ERR_DROP, "CL_ParseDownload: Invalid size %d for download chunk", size);
-		return;
-	}
-	
-	MSG_ReadData(msg, data, size);
+	//size = MSG_ReadShort ( msg );
+	//if (size < 0 || size > sizeof(data))
+	//{
+	//	Com_Error(ERR_DROP, "CL_ParseDownload: Invalid size %d for download chunk", size);
+	//	return;
+	//}
+	//
+	//MSG_ReadData(msg, data, size);
 
-	if((clc.downloadBlock & 0xFFFF) != block)
-	{
-		Com_DPrintf( "CL_ParseDownload: Expected block %d, got %d\n", (clc.downloadBlock & 0xFFFF), block);
-		return;
-	}
+	//if((clc.downloadBlock & 0xFFFF) != block)
+	//{
+	//	Com_DPrintf( "CL_ParseDownload: Expected block %d, got %d\n", (clc.downloadBlock & 0xFFFF), block);
+	//	return;
+	//}
 
-	// open the file if not opened yet
-	if (!clc.download)
-	{
-		clc.download = FS_SV_FOpenFileWrite( clc.downloadTempName );
+	//// open the file if not opened yet
+	//if (!clc.download)
+	//{
+	//	clc.download = FS_SV_FOpenFileWrite( clc.downloadTempName );
 
-		if (!clc.download) {
-			Com_Printf( "Could not create %s\n", clc.downloadTempName );
-			CL_AddReliableCommand("stopdl", qfalse);
-			CL_NextDownload();
-			return;
-		}
-	}
+	//	if (!clc.download) {
+	//		Com_Printf( "Could not create %s\n", clc.downloadTempName );
+	//		CL_AddReliableCommand("stopdl", qfalse);
+	//		CL_NextDownload();
+	//		return;
+	//	}
+	//}
 
-	if (size)
-		FS_Write( data, size, clc.download );
+	//if (size)
+	//	FS_Write( data, size, clc.download );
 
-	CL_AddReliableCommand(va("nextdl %d", clc.downloadBlock), qfalse);
-	clc.downloadBlock++;
+	//CL_AddReliableCommand(va("nextdl %d", clc.downloadBlock), qfalse);
+	//clc.downloadBlock++;
 
-	clc.downloadCount += size;
+	//clc.downloadCount += size;
 
-	// So UI gets access to it
-	Cvar_SetValue( "cl_downloadCount", clc.downloadCount );
+	//// So UI gets access to it
+	//Cvar_SetValue( "cl_downloadCount", clc.downloadCount );
 
-	if (!size) { // A zero length block means EOF
-		if (clc.download) {
-			FS_FCloseFile( clc.download );
-			clc.download = 0;
+	//if (!size) { // A zero length block means EOF
+	//	if (clc.download) {
+	//		FS_FCloseFile( clc.download );
+	//		clc.download = 0;
 
-			// rename the file
-			FS_SV_Rename ( clc.downloadTempName, clc.downloadName );
-		}
+	//		// rename the file
+	//		FS_SV_Rename ( clc.downloadTempName, clc.downloadName );
+	//	}
 
-		// send intentions now
-		// We need this because without it, we would hold the last nextdl and then start
-		// loading right away.  If we take a while to load, the server is happily trying
-		// to send us that last block over and over.
-		// Write it twice to help make sure we acknowledge the download
-		CL_WritePacket();
-		CL_WritePacket();
+	//	// send intentions now
+	//	// We need this because without it, we would hold the last nextdl and then start
+	//	// loading right away.  If we take a while to load, the server is happily trying
+	//	// to send us that last block over and over.
+	//	// Write it twice to help make sure we acknowledge the download
+	//	CL_WritePacket();
+	//	CL_WritePacket();
 
-		// get another file if needed
-		CL_NextDownload ();
-	}
+	//	// get another file if needed
+	//	CL_NextDownload ();
+	//}
 }
 
 #ifdef USE_VOIP
Index: code/client/cl_scrn.cpp
===================================================================
--- code/client/cl_scrn.cpp	(revision 284)
+++ code/client/cl_scrn.cpp	(working copy)
@@ -341,7 +341,7 @@
 		return;
 	}
 
-	pos = FS_FTell( clc.demofile );
+	pos = clc.demofile->getPos();
 	sprintf( string, "RECORDING %s: %ik", clc.demoName, pos / 1024 );
 
 	SCR_DrawStringExt( 320 - strlen( string ) * 4, 20, 8, string, g_color_table[7], qtrue, qfalse );
Index: code/client/cl_ui.cpp
===================================================================
--- code/client/cl_ui.cpp	(revision 183)
+++ code/client/cl_ui.cpp	(working copy)
@@ -28,23 +28,23 @@
 ====================
 */
 void LAN_LoadCachedServers( void ) {
-	int size;
-	fileHandle_t fileIn;
-	cls.numglobalservers = cls.numfavoriteservers = 0;
-	cls.numGlobalServerAddresses = 0;
-	if (FS_SV_FOpenFileRead("servercache.dat", &fileIn)) {
-		FS_Read(&cls.numglobalservers, sizeof(int), fileIn);
-		FS_Read(&cls.numfavoriteservers, sizeof(int), fileIn);
-		FS_Read(&size, sizeof(int), fileIn);
-		if (size == sizeof(cls.globalServers) + sizeof(cls.favoriteServers)) {
-			FS_Read(&cls.globalServers, sizeof(cls.globalServers), fileIn);
-			FS_Read(&cls.favoriteServers, sizeof(cls.favoriteServers), fileIn);
-		} else {
-			cls.numglobalservers = cls.numfavoriteservers = 0;
-			cls.numGlobalServerAddresses = 0;
-		}
-		FS_FCloseFile(fileIn);
-	}
+	//int size;
+	//vfsFileAPI_i * fileIn;
+	//cls.numglobalservers = cls.numfavoriteservers = 0;
+	//cls.numGlobalServerAddresses = 0;
+	//if (FS_SV_FOpenFileRead("servercache.dat", &fileIn)) {
+	//	FS_Read(&cls.numglobalservers, sizeof(int), fileIn);
+	//	FS_Read(&cls.numfavoriteservers, sizeof(int), fileIn);
+	//	FS_Read(&size, sizeof(int), fileIn);
+	//	if (size == sizeof(cls.globalServers) + sizeof(cls.favoriteServers)) {
+	//		FS_Read(&cls.globalServers, sizeof(cls.globalServers), fileIn);
+	//		FS_Read(&cls.favoriteServers, sizeof(cls.favoriteServers), fileIn);
+	//	} else {
+	//		cls.numglobalservers = cls.numfavoriteservers = 0;
+	//		cls.numGlobalServerAddresses = 0;
+	//	}
+	//	FS_FCloseFile(fileIn);
+	//}
 }
 
 /*
@@ -53,15 +53,15 @@
 ====================
 */
 void LAN_SaveServersToCache( void ) {
-	int size;
-	fileHandle_t fileOut = FS_SV_FOpenFileWrite("servercache.dat");
-	FS_Write(&cls.numglobalservers, sizeof(int), fileOut);
-	FS_Write(&cls.numfavoriteservers, sizeof(int), fileOut);
-	size = sizeof(cls.globalServers) + sizeof(cls.favoriteServers);
-	FS_Write(&size, sizeof(int), fileOut);
-	FS_Write(&cls.globalServers, sizeof(cls.globalServers), fileOut);
-	FS_Write(&cls.favoriteServers, sizeof(cls.favoriteServers), fileOut);
-	FS_FCloseFile(fileOut);
+	//int size;
+	//vfsFileAPI_i * fileOut = FS_SV_FOpenFileWrite("servercache.dat");
+	//FS_Write(&cls.numglobalservers, sizeof(int), fileOut);
+	//FS_Write(&cls.numfavoriteservers, sizeof(int), fileOut);
+	//size = sizeof(cls.globalServers) + sizeof(cls.favoriteServers);
+	//FS_Write(&size, sizeof(int), fileOut);
+	//FS_Write(&cls.globalServers, sizeof(cls.globalServers), fileOut);
+	//FS_Write(&cls.favoriteServers, sizeof(cls.favoriteServers), fileOut);
+	//FS_FCloseFile(fileOut);
 }
 
 
Index: code/client/client.h
===================================================================
--- code/client/client.h	(revision 183)
+++ code/client/client.h	(working copy)
@@ -189,7 +189,7 @@
 	char		serverCommands[MAX_RELIABLE_COMMANDS][MAX_STRING_CHARS];
 
 	// file transfer from server
-	fileHandle_t download;
+	vfsFileAPI_i * download;
 	char		downloadTempName[MAX_OSPATH];
 	char		downloadName[MAX_OSPATH];
 #ifdef USE_CURL
@@ -216,7 +216,7 @@
 	qboolean	demoplaying;
 	qboolean	demowaiting;	// don't record until a non-delta message is received
 	qboolean	firstDemoFrameSkipped;
-	fileHandle_t	demofile;
+	vfsFileAPI_i *	demofile;
 
 	int			timeDemoFrames;		// counter of rendered frames
 	int			timeDemoStart;		// cls.realtime before first frame
Index: code/client/keys.h
===================================================================
--- code/client/keys.h	(revision 183)
+++ code/client/keys.h	(working copy)
@@ -45,7 +45,7 @@
 extern	qboolean	chat_team;
 extern	int			chat_playerNum;
 
-void Key_WriteBindings( fileHandle_t f );
+void Key_WriteBindings( vfsFileAPI_i * f );
 void Key_SetBinding( int keynum, const char *binding );
 char *Key_GetBinding( int keynum );
 qboolean Key_IsDown( int keynum );
Index: code/cm/cm_api.cpp
===================================================================
--- code/cm/cm_api.cpp	(revision 228)
+++ code/cm/cm_api.cpp	(working copy)
@@ -58,7 +58,7 @@
 // interface manager (import)
 class iFaceMgrAPI_i *g_iFaceMan = 0;
 // imports
-vfsAPI_s *g_vfs = 0;
+vfsAPI_i *g_vfs = 0;
 cvarsAPI_s *g_cvars = 0;
 coreAPI_s *g_core = 0;
 modelLoaderDLLAPI_i *g_modelLoader = 0;
Index: code/declManager/declManagerIMPL.cpp
===================================================================
--- code/declManager/declManagerIMPL.cpp	(revision 291)
+++ code/declManager/declManagerIMPL.cpp	(working copy)
@@ -508,7 +508,7 @@
 }
 void fileTextDataCache_c::cacheDefFileText(const char *fname) {
 	char *data;
-	u32 len = g_vfs->FS_ReadFile(fname,(void**)&data);
+	u32 len = g_vfs->loadFileData(fname,(byte**)&data);
 	if(data == 0)
 		return;
 	totalDefBytes += len;
@@ -517,20 +517,20 @@
 	defFile_s *df = new defFile_s;
 	df->fname = fname;
 	df->text = data;
-	g_vfs->FS_FreeFile(data);
+	g_vfs->freeFileData((byte**)&data);
 	defFiles.push_back(df);
 }
 u32 fileTextDataCache_c::cacheFileList(const char *path, const char *ext) {
 	int numFiles;
 	totalDefBytes = 0;
-	char **fnames = g_vfs->FS_ListFiles(path,ext,&numFiles);
-	for(u32 i = 0; i < numFiles; i++) {
-		const char *fname = fnames[i];
+	vfsFileListAPI_i *list = g_vfs->listFiles(path,ext);
+	for(u32 i = 0; i < list->getNumFiles(); i++) {
+		const char *fname = list->getFileName(i);
 		str fullPath = path;
 		fullPath.append(fname);
 		cacheDefFileText(fullPath);
 	}
-	g_vfs->FS_FreeFileList(fnames);
+	g_vfs->freeFileList(list);
 	return numFiles;
 }
 void declManagerIMPL_c::init() {
@@ -550,7 +550,7 @@
 // interface manager (import)
 class iFaceMgrAPI_i *g_iFaceMan = 0;
 // imports
-vfsAPI_s *g_vfs = 0;
+vfsAPI_i *g_vfs = 0;
 cvarsAPI_s *g_cvars = 0;
 coreAPI_s *g_core = 0;
 modelLoaderDLLAPI_i *g_modelLoader = 0;
Index: code/external/bullet-2.80-rev2531/lib/bulletcollision_debug.idb
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: code/external/bullet-2.80-rev2531/lib/BulletCollision_debug.lib
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: code/external/bullet-2.80-rev2531/lib/bulletcollision_debug.pdb
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: code/external/bullet-2.80-rev2531/lib/bulletdynamics_debug.idb
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: code/external/bullet-2.80-rev2531/lib/BulletDynamics_debug.lib
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: code/external/bullet-2.80-rev2531/lib/bulletdynamics_debug.pdb
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: code/external/bullet-2.80-rev2531/lib/linearmath_debug.idb
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: code/external/bullet-2.80-rev2531/lib/LinearMath_debug.lib
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: code/external/bullet-2.80-rev2531/lib/linearmath_debug.pdb
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: code/game/g_api.cpp
===================================================================
--- code/game/g_api.cpp	(revision 210)
+++ code/game/g_api.cpp	(working copy)
@@ -39,7 +39,7 @@
 class iFaceMgrAPI_i *g_iFaceMan = 0;
 // imports
 svAPI_s *g_server = 0;
-vfsAPI_s *g_vfs = 0;
+vfsAPI_i *g_vfs = 0;
 cvarsAPI_s *g_cvars = 0;
 coreAPI_s *g_core = 0;
 cmAPI_i *cm = 0;
Index: code/game/g_bullet.cpp
===================================================================
--- code/game/g_bullet.cpp	(revision 286)
+++ code/game/g_bullet.cpp	(working copy)
@@ -1034,19 +1034,19 @@
 		out.append("maps/");
 	}
 	out.append(mapName);
-	if(g_vfs->FS_FileExists(out) == true) {
+	if(g_vfs->fileExists(out) == true) {
 		return false; // OK
 	}
 	out.setExtension("bsp");
-	if(g_vfs->FS_FileExists(out) == true) {
+	if(g_vfs->fileExists(out) == true) {
 		return false; // OK
 	}
 	out.setExtension("proc");
-	if(g_vfs->FS_FileExists(out) == true) {
+	if(g_vfs->fileExists(out) == true) {
 		return false; // OK
 	}
 	out.setExtension("map");
-	if(g_vfs->FS_FileExists(out) == true) {
+	if(g_vfs->fileExists(out) == true) {
 		return false; // OK
 	}
 	return true; // error
@@ -1073,7 +1073,7 @@
 			str fixed = "maps/";
 			fixed.append(mapName);
 			fixed.setExtension("proc");
-			if(g_vfs->FS_FileExists(fixed)) {
+			if(g_vfs->fileExists(fixed)) {
 				g_worldSurface.loadDoom3ProcFileWorldModel(fixed);
 			} else {
 				fixed = "maps/";
Index: code/game/g_client.cpp
===================================================================
--- code/game/g_client.cpp	(revision 276)
+++ code/game/g_client.cpp	(working copy)
@@ -351,10 +351,10 @@
 			vec3_c spawnPos = pl->getOrigin();
 			spawnPos.z += pl->getViewHeight();
 			spawnPos += pl->getForward() * 64.f;
-			if(g_vfs->FS_ReadFile(model,0) < 1) {
+			if(g_vfs->fileExists(model) == false) {
 				str fixed = "models/";
 				fixed.append(model);
-				if(g_vfs->FS_ReadFile(model,0) < 1) {
+				if(g_vfs->fileExists(fixed) == false) {
 					// if "model" string is not a file name,
 					// it might a entityDef name from .def files (Doom3 declarations)
 					if(g_declMgr->registerEntityDecl(model)) {
@@ -396,10 +396,10 @@
 	} else if(!stricmp(cmd,"spawnStatic")) {
 		str model = g_core->Argv(1);
 		if(model.length()) {
-			if(g_vfs->FS_ReadFile(model,0) < 1) {
+			if(g_vfs->fileExists(model) == false) {
 				str fixed = "models/";
 				fixed.append(model);
-				if(g_vfs->FS_ReadFile(model,0) < 1) {
+				if(g_vfs->fileExists(fixed) == false) {
 					g_core->Print("%s does not exist\n",model.c_str());
 					return;
 				}
Index: code/game/g_public.h
===================================================================
--- code/game/g_public.h	(revision 183)
+++ code/game/g_public.h	(working copy)
@@ -80,10 +80,10 @@
 
 	G_ARGV,			// ( int n, char *buffer, int bufferLength );
 
-	G_FS_FOPEN_FILE,	// ( const char *qpath, fileHandle_t *file, fsMode_t mode );
-	G_FS_READ,		// ( void *buffer, int len, fileHandle_t f );
-	G_FS_WRITE,		// ( const void *buffer, int len, fileHandle_t f );
-	G_FS_FCLOSE_FILE,		// ( fileHandle_t f );
+	G_FS_FOPEN_FILE,	// ( const char *qpath, vfsFileAPI_i * *file, fsMode_t mode );
+	G_FS_READ,		// ( void *buffer, int len, vfsFileAPI_i * f );
+	G_FS_WRITE,		// ( const void *buffer, int len, vfsFileAPI_i * f );
+	G_FS_FCLOSE_FILE,		// ( vfsFileAPI_i * f );
 
 	//=========== server specific functionality =============
 
Index: code/imageLib/img_api.cpp
===================================================================
--- code/imageLib/img_api.cpp	(revision 280)
+++ code/imageLib/img_api.cpp	(working copy)
@@ -49,7 +49,7 @@
 // interface manager (import)
 class iFaceMgrAPI_i *g_iFaceMan = 0;
 // imports
-vfsAPI_s *g_vfs = 0;
+vfsAPI_i *g_vfs = 0;
 cvarsAPI_s *g_cvars = 0;
 coreAPI_s *g_core = 0;
 // exports
Index: code/imageLib/img_devil.cpp
===================================================================
--- code/imageLib/img_devil.cpp	(revision 183)
+++ code/imageLib/img_devil.cpp	(working copy)
@@ -322,12 +322,12 @@
 
 	byte *buf = 0;
 	u32 len;
-	len = g_vfs->FS_ReadFile(s,(void**)&buf);
+	len = g_vfs->loadFileData(s,&buf);
 	if(buf == 0) {
 		for(u32 i = 0; i < img_numSupportedImageTypes; i++) {
 			imgType_s *t = &img_types[i];
 			s.setExtension(t->ext);
-			len = g_vfs->FS_ReadFile(s,(void**)&buf);
+			len = g_vfs->loadFileData(s,&buf);
 			if(buf)
 				break;
 		}
@@ -340,7 +340,7 @@
 	if(1 && !stricmp(ext,"tga")) {
 		// devil tga loader swaps colors....
 		IMG_LoadTGA( s, imageData, buf, width, height ); 
-		g_vfs->FS_FreeFile(buf);
+		g_vfs->freeFileData(&buf);
 		strcpy(lastValidFName,s.c_str());
 		return lastValidFName;
 	}
@@ -355,7 +355,7 @@
 	ILboolean done = 0;
 	done = ilLoadL(type,buf,len);
 	//g_core->Print("result %i\n",done);
-	g_vfs->FS_FreeFile(buf);
+	g_vfs->freeFileData(&buf);
 	if(!done) {
 		ilBindImage(0);
 		ilDeleteImages(1, &ilTexture);
Index: code/materialSystem/mat_api.cpp
===================================================================
--- code/materialSystem/mat_api.cpp	(revision 294)
+++ code/materialSystem/mat_api.cpp	(working copy)
@@ -80,7 +80,7 @@
 // interface manager (import)
 class iFaceMgrAPI_i *g_iFaceMan = 0;
 // imports
-vfsAPI_s *g_vfs = 0;
+vfsAPI_i *g_vfs = 0;
 cvarsAPI_s *g_cvars = 0;
 coreAPI_s *g_core = 0;
 rAPI_i *rf = 0;
Index: code/materialSystem/mat_main.cpp
===================================================================
--- code/materialSystem/mat_main.cpp	(revision 296)
+++ code/materialSystem/mat_main.cpp	(working copy)
@@ -39,13 +39,13 @@
 	bool reloadMaterialSourceText() {
 		text.clear();
 		char *tmpFileData;
-		u32 len = g_vfs->FS_ReadFile(this->fname,(void**)&tmpFileData);
+		u32 len = g_vfs->loadFileData(this->fname,(byte**)&tmpFileData);
 		if(tmpFileData == 0) {
 			g_core->RedWarning("matFile_s::reloadMaterialSourceText: failed to reload file %s\n",this->fname.c_str());
 			return true; // error
 		}
 		this->text = tmpFileData;
-		g_vfs->FS_FreeFile(tmpFileData);
+		g_vfs->freeFileData((byte**)&tmpFileData);
 		return false;
 	}
 };
@@ -55,13 +55,13 @@
 
 void MAT_CacheMatFileText(const char *fname) {
 	char *data;
-	u32 len = g_vfs->FS_ReadFile(fname,(void**)&data);
+	u32 len = g_vfs->loadFileData(fname,(byte**)&data);
 	if(data == 0)
 		return;
 	matFile_s *mf = new matFile_s;
 	mf->fname = fname;
 	mf->text = data;
-	g_vfs->FS_FreeFile(data);
+	g_vfs->freeFileData((byte**)&data);
 	matFiles.push_back(mf);
 }
 const char *MAT_FindMaterialDefInText(const char *matName, const char *text) {
@@ -112,15 +112,14 @@
 }
 
 void MAT_ScanForFiles(const char *path, const char *ext) {
-	int numFiles;
-	char **fnames = g_vfs->FS_ListFiles(path,ext,&numFiles);
-	for(u32 i = 0; i < numFiles; i++) {
-		const char *fname = fnames[i];
+	class vfsFileListAPI_i *list = g_vfs->listFiles(path,ext);
+	for(u32 i = 0; i < list->getNumFiles(); i++) {
+		const char *fname = list->getFileName(i);
 		str fullPath = path;
 		fullPath.append(fname);
 		MAT_CacheMatFileText(fullPath);
 	}
-	g_vfs->FS_FreeFileList(fnames);
+	g_vfs->freeFileList(list);
 }
 void MAT_ScanForMaterialFiles() {
 	MAT_ScanForFiles("scripts/",".shader");
@@ -212,7 +211,7 @@
 			}
 		}
 		g_core->Print("MAT_ReloadMaterialFileSource: reloaded %i materials for source file %s\n",c_reloadedMats,mtrSourceFileName);
-	} else if(g_vfs->FS_FileExists(mtrSourceFileName)) {
+	} else if(g_vfs->fileExists(mtrSourceFileName)) {
 		g_core->Print("MAT_ReloadMaterialFileSource: loading NEW materials source file %s\n",mtrSourceFileName);
 		// add a NEW material file
 		MAT_CacheMatFileText(mtrSourceFileName);
Index: code/modelLoader/hl2MDLReader.cpp
===================================================================
--- code/modelLoader/hl2MDLReader.cpp	(revision 296)
+++ code/modelLoader/hl2MDLReader.cpp	(working copy)
@@ -216,8 +216,13 @@
 	vvd = 0;
 }
 hl2MDLReader_c::~hl2MDLReader_c() {
-
+	clear();
 }
+void hl2MDLReader_c::clear() {
+	if(vvd) {
+		g_vfs->freeFileData((byte**)&vvd);
+	}
+}
 bool hl2MDLReader_c::beginReading(const char *fname) {
 	if(data.loadFromFile(fname)) {
 		g_core->RedWarning("hl2MDLReader_c::beginReading: cannot open %s\n",fname);
@@ -232,7 +237,7 @@
 	
 	str vvdFileName = fname;
 	vvdFileName.setExtension("vvd");
-	vvdFileLen = g_vfs->FS_ReadFile(vvdFileName,(void**)&vvd);
+	vvdFileLen = g_vfs->loadFileData(vvdFileName,(byte**)&vvd);
 	if(vvd == 0) {
 		g_core->RedWarning("hl2MDLReader_c::beginReading: cannot open %s\n",vvdFileName.c_str());
 		return true; // error
Index: code/modelLoader/hl2MDLReader.h
===================================================================
--- code/modelLoader/hl2MDLReader.h	(revision 296)
+++ code/modelLoader/hl2MDLReader.h	(working copy)
@@ -44,6 +44,9 @@
 public:
 	hl2MDLReader_c();
 	~hl2MDLReader_c();
+
+	void clear();
+
 	bool beginReading(const char *fname);
 	
 	bool getStaticModelData(class staticModelCreatorAPI_i *out);
Index: code/modelLoader/keyFramedModelImpl.cpp
===================================================================
--- code/modelLoader/keyFramedModelImpl.cpp	(revision 278)
+++ code/modelLoader/keyFramedModelImpl.cpp	(working copy)
@@ -97,11 +97,11 @@
 }
 bool kfModelImpl_c::loadMD3(const char *fname) {
 	byte *buf;
-	u32 len = g_vfs->FS_ReadFile(fname,(void**)&buf);
+	u32 len = g_vfs->loadFileData(fname,&buf);
 	if(buf == 0)
 		return true;
 	bool res = loadMD3(buf,len,fname);
-	g_vfs->FS_FreeFile(buf);
+	g_vfs->freeFileData(&buf);
 	return res;
 }
 bool kfModelImpl_c::loadMD3(const byte *buf, const u32 fileLen, const char *fname) {
@@ -181,11 +181,11 @@
 }
 bool kfModelImpl_c::loadMD2(const char *fname) {
 	byte *buf;
-	u32 len = g_vfs->FS_ReadFile(fname,(void**)&buf);
+	u32 len = g_vfs->loadFileData(fname,&buf);
 	if(buf == 0)
 		return true;
 	bool res = loadMD2(buf,len,fname);
-	g_vfs->FS_FreeFile(buf);
+	g_vfs->freeFileData(&buf);
 	return res;
 }
 bool kfModelImpl_c::loadMD2(const byte *buf, const u32 fileLen, const char *fname) {
@@ -262,7 +262,7 @@
 	return false; // no error
 }
 kfModelImpl_c *KF_LoadKeyFramedModel(const char *fname) {
-	if(g_vfs->FS_FileExists(fname)==false) {
+	if(g_vfs->fileExists(fname)==false) {
 		g_core->RedWarning("KF_LoadKeyFramedModel: file %s does not exist\n",fname);
 		return 0;
 	}
Index: code/modelLoader/modelLoaderAPI.cpp
===================================================================
--- code/modelLoader/modelLoaderAPI.cpp	(revision 296)
+++ code/modelLoader/modelLoaderAPI.cpp	(working copy)
@@ -244,7 +244,7 @@
 // interface manager (import)
 class iFaceMgrAPI_i *g_iFaceMan = 0;
 // imports
-vfsAPI_s *g_vfs = 0;
+vfsAPI_i *g_vfs = 0;
 cvarsAPI_s *g_cvars = 0;
 coreAPI_s *g_core = 0;
 materialSystemAPI_i *g_ms = 0;
Index: code/modelLoader/staticModelLoaders/md3StaticLoader.cpp
===================================================================
--- code/modelLoader/staticModelLoaders/md3StaticLoader.cpp	(revision 274)
+++ code/modelLoader/staticModelLoaders/md3StaticLoader.cpp	(working copy)
@@ -33,7 +33,7 @@
 bool MOD_LoadStaticMD3(const char *fname, staticModelCreatorAPI_i *out) {
 	byte *fileData;
 	// load raw file data from disk
-	u32 fileLen = g_vfs->FS_ReadFile(fname,(void**)&fileData);
+	u32 fileLen = g_vfs->loadFileData(fname,&fileData);
 	if(fileData == 0) {
 		return true; // cannot open file
 	}
@@ -42,13 +42,13 @@
 	if(h->ident != MD3_IDENT) {
 		g_core->RedWarning("MOD_LoadStaticMD3: %s has bad ident\n",fname);
 		// free loaded file data
-		g_vfs->FS_FreeFile(fileData);
+		g_vfs->freeFileData(&fileData);
 		return true;
 	}
 	if(h->version != MD3_VERSION) {
 		g_core->RedWarning("MOD_LoadStaticMD3: %s has bad version %i (should be %i)\n",fname,h->version,MD3_VERSION);
 		// free loaded file data
-		g_vfs->FS_FreeFile(fileData);
+		g_vfs->freeFileData(&fileData);
 		return true;
 	}
 	u32 loadFrameNum = 0;
@@ -97,14 +97,14 @@
 	}
 	out->recalcBoundingBoxes();
 	// free loaded file data
-	g_vfs->FS_FreeFile(fileData);
+	g_vfs->freeFileData(&fileData);
 	return false; // no error
 }
 
 u32 MOD_ReadMD3FileFrameCount(const char *fname) {
 	byte *fileData;
 	// load raw file data from disk
-	u32 fileLen = g_vfs->FS_ReadFile(fname,(void**)&fileData);
+	u32 fileLen = g_vfs->loadFileData(fname,&fileData);
 	if(fileData == 0) {
 		return 0; // cannot open file
 	}
@@ -114,6 +114,6 @@
 	u32 numFrames = h->numFrames;
 
 	// free loaded file data
-	g_vfs->FS_FreeFile(fileData);
+	g_vfs->freeFileData(&fileData);
 	return numFrames;
 }
\ No newline at end of file
Index: code/qcommon/cmd.cpp
===================================================================
--- code/qcommon/cmd.cpp	(revision 183)
+++ code/qcommon/cmd.cpp	(working copy)
@@ -268,7 +268,7 @@
 	qboolean quiet;
 	union {
 		char	*c;
-		void	*v;
+		byte	*v;
 	} f;
 	char	filename[MAX_QPATH];
 
@@ -282,7 +282,7 @@
 
 	Q_strncpyz( filename, Cmd_Argv(1), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), ".cfg" );
-	FS_ReadFile( filename, &f.v);
+	g_vfs->loadFileData(filename, &f.v);
 	if (!f.c) {
 		Com_Printf ("couldn't exec %s\n", filename);
 		return;
@@ -292,7 +292,7 @@
 	
 	Cbuf_InsertText (f.c);
 
-	FS_FreeFile (f.v);
+	g_vfs->freeFileData (&f.v);
 }
 
 
Index: code/qcommon/common.cpp
===================================================================
--- code/qcommon/common.cpp	(revision 237)
+++ code/qcommon/common.cpp	(working copy)
@@ -34,6 +34,7 @@
 #include <api/moduleManagerAPI.h>
 #include <api/coreAPI.h>
 #include <api/declManagerAPI.h>
+#include <api/vfsAPI.h>
 
 int demo_protocols[] =
 { 67, 66, 0 };
@@ -60,10 +61,10 @@
 } fix;
 
 FILE *debuglogfile;
-static fileHandle_t pipefile;
-static fileHandle_t logfile;
-fileHandle_t	com_journalFile;			// events are written here
-fileHandle_t	com_journalDataFile;		// config files are written here
+static vfsFileAPI_i * pipefile;
+static vfsFileAPI_i * logfile;
+vfsFileAPI_i *	com_journalFile;			// events are written here
+vfsFileAPI_i *	com_journalDataFile;		// config files are written here
 
 cvar_s	*com_speeds;
 cvar_s	*com_developer;
@@ -200,7 +201,7 @@
 	if ( com_logfile && com_logfile->integer ) {
     // TTimo: only open the qconsole.log if the filesystem is in an initialized state
     //   also, avoid recursing in the qconsole.log opening (i.e. if fs_debug is on)
-		if ( !logfile && FS_Initialized() && !opening_qconsole) {
+		if ( !logfile && g_vfs && !opening_qconsole) {
 			struct tm *newtime;
 			time_t aclock;
 
@@ -209,7 +210,7 @@
 			time( &aclock );
 			newtime = localtime( &aclock );
 
-			logfile = FS_FOpenFileWrite( "qconsole.log" );
+			logfile = g_vfs->openFile("qconsole.log", "w");
 			
 			if(logfile)
 			{
@@ -219,7 +220,7 @@
 				{
 					// force it to not buffer so we get valid
 					// data even if we are crashing
-					FS_ForceFlush(logfile);
+					logfile->forceFlush();
 				}
 			}
 			else
@@ -230,8 +231,8 @@
 
       opening_qconsole = qfalse;
 		}
-		if ( logfile && FS_Initialized()) {
-			FS_Write(msg, strlen(msg), logfile);
+		if (g_vfs && logfile) {
+			logfile->writeData(msg, strlen(msg));
 		}
 	}
 }
@@ -321,7 +322,7 @@
 		CL_FlushMemory( );
 //		VM_Forced_Unload_Done();
 		// make sure we can get at our local stuff
-		FS_PureServerSetLoadedPaks("", "");
+		//FS_PureServerSetLoadedPaks("", "");
 		com_errorEntered = qfalse;
 		longjmp (abortframe, -1);
 	} else if (code == ERR_DROP) {
@@ -331,7 +332,7 @@
 		CL_Disconnect( qtrue );
 		CL_FlushMemory( );
 //		VM_Forced_Unload_Done();
-		FS_PureServerSetLoadedPaks("", "");
+		//FS_PureServerSetLoadedPaks("", "");
 		com_errorEntered = qfalse;
 		longjmp (abortframe, -1);
 	} else if ( code == ERR_NEED_CD ) {
@@ -347,7 +348,7 @@
 //			VM_Forced_Unload_Done();
 		}
 
-		FS_PureServerSetLoadedPaks("", "");
+		//FS_PureServerSetLoadedPaks("", "");
 
 		com_errorEntered = qfalse;
 		longjmp (abortframe, -1);
@@ -395,7 +396,7 @@
 		CL_Shutdown(p[0] ? p : "Client quit", qtrue, qtrue);
 //		VM_Forced_Unload_Done();
 		Com_Shutdown ();
-		FS_Shutdown(qtrue);
+		g_vfs->shutdown();
 	}
 	Sys_Quit ();
 }
@@ -1115,54 +1116,54 @@
 ========================
 */
 void Z_LogZoneHeap( memzone_t *zone, char *name ) {
-#ifdef ZONE_DEBUG
-	char dump[32], *ptr;
-	int  i, j;
-#endif
-	memblock_t	*block;
-	char		buf[4096];
-	int size, allocSize, numBlocks;
-
-	if (!logfile || !FS_Initialized())
-		return;
-	size = numBlocks = 0;
-#ifdef ZONE_DEBUG
-	allocSize = 0;
-#endif
-	Com_sprintf(buf, sizeof(buf), "\r\n================\r\n%s log\r\n================\r\n", name);
-	FS_Write(buf, strlen(buf), logfile);
-	for (block = zone->blocklist.next ; block->next != &zone->blocklist; block = block->next) {
-		if (block->tag) {
-#ifdef ZONE_DEBUG
-			ptr = ((char *) block) + sizeof(memblock_t);
-			j = 0;
-			for (i = 0; i < 20 && i < block->d.allocSize; i++) {
-				if (ptr[i] >= 32 && ptr[i] < 127) {
-					dump[j++] = ptr[i];
-				}
-				else {
-					dump[j++] = '_';
-				}
-			}
-			dump[j] = '\0';
-			Com_sprintf(buf, sizeof(buf), "size = %8d: %s, line: %d (%s) [%s]\r\n", block->d.allocSize, block->d.file, block->d.line, block->d.label, dump);
-			FS_Write(buf, strlen(buf), logfile);
-			allocSize += block->d.allocSize;
-#endif
-			size += block->size;
-			numBlocks++;
-		}
-	}
-#ifdef ZONE_DEBUG
-	// subtract debug memory
-	size -= numBlocks * sizeof(zonedebug_t);
-#else
-	allocSize = numBlocks * sizeof(memblock_t); // + 32 bit alignment
-#endif
-	Com_sprintf(buf, sizeof(buf), "%d %s memory in %d blocks\r\n", size, name, numBlocks);
-	FS_Write(buf, strlen(buf), logfile);
-	Com_sprintf(buf, sizeof(buf), "%d %s memory overhead\r\n", size - allocSize, name);
-	FS_Write(buf, strlen(buf), logfile);
+//#ifdef ZONE_DEBUG
+//	char dump[32], *ptr;
+//	int  i, j;
+//#endif
+//	memblock_t	*block;
+//	char		buf[4096];
+//	int size, allocSize, numBlocks;
+//
+//	if (!logfile || !g_vfs)
+//		return;
+//	size = numBlocks = 0;
+//#ifdef ZONE_DEBUG
+//	allocSize = 0;
+//#endif
+//	Com_sprintf(buf, sizeof(buf), "\r\n================\r\n%s log\r\n================\r\n", name);
+//	FS_Write(buf, strlen(buf), logfile);
+//	for (block = zone->blocklist.next ; block->next != &zone->blocklist; block = block->next) {
+//		if (block->tag) {
+//#ifdef ZONE_DEBUG
+//			ptr = ((char *) block) + sizeof(memblock_t);
+//			j = 0;
+//			for (i = 0; i < 20 && i < block->d.allocSize; i++) {
+//				if (ptr[i] >= 32 && ptr[i] < 127) {
+//					dump[j++] = ptr[i];
+//				}
+//				else {
+//					dump[j++] = '_';
+//				}
+//			}
+//			dump[j] = '\0';
+//			Com_sprintf(buf, sizeof(buf), "size = %8d: %s, line: %d (%s) [%s]\r\n", block->d.allocSize, block->d.file, block->d.line, block->d.label, dump);
+//			FS_Write(buf, strlen(buf), logfile);
+//			allocSize += block->d.allocSize;
+//#endif
+//			size += block->size;
+//			numBlocks++;
+//		}
+//	}
+//#ifdef ZONE_DEBUG
+//	// subtract debug memory
+//	size -= numBlocks * sizeof(zonedebug_t);
+//#else
+//	allocSize = numBlocks * sizeof(memblock_t); // + 32 bit alignment
+//#endif
+//	Com_sprintf(buf, sizeof(buf), "%d %s memory in %d blocks\r\n", size, name, numBlocks);
+//	FS_Write(buf, strlen(buf), logfile);
+//	Com_sprintf(buf, sizeof(buf), "%d %s memory overhead\r\n", size - allocSize, name);
+//	FS_Write(buf, strlen(buf), logfile);
 }
 
 /*
@@ -1480,28 +1481,28 @@
 =================
 */
 void Hunk_Log( void) {
-	hunkblock_t	*block;
-	char		buf[4096];
-	int size, numBlocks;
-
-	if (!logfile || !FS_Initialized())
-		return;
-	size = 0;
-	numBlocks = 0;
-	Com_sprintf(buf, sizeof(buf), "\r\n================\r\nHunk log\r\n================\r\n");
-	FS_Write(buf, strlen(buf), logfile);
-	for (block = hunkblocks ; block; block = block->next) {
-#ifdef HUNK_DEBUG
-		Com_sprintf(buf, sizeof(buf), "size = %8d: %s, line: %d (%s)\r\n", block->size, block->file, block->line, block->label);
-		FS_Write(buf, strlen(buf), logfile);
-#endif
-		size += block->size;
-		numBlocks++;
-	}
-	Com_sprintf(buf, sizeof(buf), "%d Hunk memory\r\n", size);
-	FS_Write(buf, strlen(buf), logfile);
-	Com_sprintf(buf, sizeof(buf), "%d hunk blocks\r\n", numBlocks);
-	FS_Write(buf, strlen(buf), logfile);
+//	hunkblock_t	*block;
+//	char		buf[4096];
+//	int size, numBlocks;
+//
+//	if (!logfile || !FS_Initialized())
+//		return;
+//	size = 0;
+//	numBlocks = 0;
+//	Com_sprintf(buf, sizeof(buf), "\r\n================\r\nHunk log\r\n================\r\n");
+//	FS_Write(buf, strlen(buf), logfile);
+//	for (block = hunkblocks ; block; block = block->next) {
+//#ifdef HUNK_DEBUG
+//		Com_sprintf(buf, sizeof(buf), "size = %8d: %s, line: %d (%s)\r\n", block->size, block->file, block->line, block->label);
+//		FS_Write(buf, strlen(buf), logfile);
+//#endif
+//		size += block->size;
+//		numBlocks++;
+//	}
+//	Com_sprintf(buf, sizeof(buf), "%d Hunk memory\r\n", size);
+//	FS_Write(buf, strlen(buf), logfile);
+//	Com_sprintf(buf, sizeof(buf), "%d hunk blocks\r\n", numBlocks);
+//	FS_Write(buf, strlen(buf), logfile);
 }
 
 /*
@@ -1510,46 +1511,46 @@
 =================
 */
 void Hunk_SmallLog( void) {
-	hunkblock_t	*block, *block2;
-	char		buf[4096];
-	int size, locsize, numBlocks;
-
-	if (!logfile || !FS_Initialized())
-		return;
-	for (block = hunkblocks ; block; block = block->next) {
-		block->printed = qfalse;
-	}
-	size = 0;
-	numBlocks = 0;
-	Com_sprintf(buf, sizeof(buf), "\r\n================\r\nHunk Small log\r\n================\r\n");
-	FS_Write(buf, strlen(buf), logfile);
-	for (block = hunkblocks; block; block = block->next) {
-		if (block->printed) {
-			continue;
-		}
-		locsize = block->size;
-		for (block2 = block->next; block2; block2 = block2->next) {
-			if (block->line != block2->line) {
-				continue;
-			}
-			if (Q_stricmp(block->file, block2->file)) {
-				continue;
-			}
-			size += block2->size;
-			locsize += block2->size;
-			block2->printed = qtrue;
-		}
-#ifdef HUNK_DEBUG
-		Com_sprintf(buf, sizeof(buf), "size = %8d: %s, line: %d (%s)\r\n", locsize, block->file, block->line, block->label);
-		FS_Write(buf, strlen(buf), logfile);
-#endif
-		size += block->size;
-		numBlocks++;
-	}
-	Com_sprintf(buf, sizeof(buf), "%d Hunk memory\r\n", size);
-	FS_Write(buf, strlen(buf), logfile);
-	Com_sprintf(buf, sizeof(buf), "%d hunk blocks\r\n", numBlocks);
-	FS_Write(buf, strlen(buf), logfile);
+//	hunkblock_t	*block, *block2;
+//	char		buf[4096];
+//	int size, locsize, numBlocks;
+//
+//	if (!logfile || !FS_Initialized())
+//		return;
+//	for (block = hunkblocks ; block; block = block->next) {
+//		block->printed = qfalse;
+//	}
+//	size = 0;
+//	numBlocks = 0;
+//	Com_sprintf(buf, sizeof(buf), "\r\n================\r\nHunk Small log\r\n================\r\n");
+//	FS_Write(buf, strlen(buf), logfile);
+//	for (block = hunkblocks; block; block = block->next) {
+//		if (block->printed) {
+//			continue;
+//		}
+//		locsize = block->size;
+//		for (block2 = block->next; block2; block2 = block2->next) {
+//			if (block->line != block2->line) {
+//				continue;
+//			}
+//			if (Q_stricmp(block->file, block2->file)) {
+//				continue;
+//			}
+//			size += block2->size;
+//			locsize += block2->size;
+//			block2->printed = qtrue;
+//		}
+//#ifdef HUNK_DEBUG
+//		Com_sprintf(buf, sizeof(buf), "size = %8d: %s, line: %d (%s)\r\n", locsize, block->file, block->line, block->label);
+//		FS_Write(buf, strlen(buf), logfile);
+//#endif
+//		size += block->size;
+//		numBlocks++;
+//	}
+//	Com_sprintf(buf, sizeof(buf), "%d Hunk memory\r\n", size);
+//	FS_Write(buf, strlen(buf), logfile);
+//	Com_sprintf(buf, sizeof(buf), "%d hunk blocks\r\n", numBlocks);
+//	FS_Write(buf, strlen(buf), logfile);
 }
 
 /*
@@ -1566,9 +1567,9 @@
 	// this allows the config and product id files ( journal files too ) to be loaded
 	// by the file system without redunant routines in the file system utilizing different 
 	// memory systems
-	if (FS_LoadStack() != 0) {
-		Com_Error( ERR_FATAL, "Hunk initialization failed. File system load stack not zero");
-	}
+	//if (FS_LoadStack() != 0) {
+	//	Com_Error( ERR_FATAL, "Hunk initialization failed. File system load stack not zero");
+	//}
 
 	// allocate the stack based hunk allocator
 	cv = Cvar_Get( "com_hunkMegs", DEF_COMHUNKMEGS_S, CVAR_LATCH | CVAR_ARCHIVE );
@@ -2062,23 +2063,24 @@
 	sysEvent_t	ev;
 
 	// either get an event from the system or the journal file
-	if ( com_journal->integer == 2 ) {
-		r = FS_Read( &ev, sizeof(ev), com_journalFile );
-		if ( r != sizeof(ev) ) {
-			Com_Error( ERR_FATAL, "Error reading from journal file" );
-		}
-		if ( ev.evPtrLength ) {
-			ev.evPtr = Z_Malloc( ev.evPtrLength );
-			r = FS_Read( ev.evPtr, ev.evPtrLength, com_journalFile );
-			if ( r != ev.evPtrLength ) {
-				Com_Error( ERR_FATAL, "Error reading from journal file" );
-			}
-		}
-	} else {
+	//if ( com_journal->integer == 2 ) {
+	//	r = FS_Read( &ev, sizeof(ev), com_journalFile );
+	//	if ( r != sizeof(ev) ) {
+	//		Com_Error( ERR_FATAL, "Error reading from journal file" );
+	//	}
+	//	if ( ev.evPtrLength ) {
+	//		ev.evPtr = Z_Malloc( ev.evPtrLength );
+	//		r = FS_Read( ev.evPtr, ev.evPtrLength, com_journalFile );
+	//		if ( r != ev.evPtrLength ) {
+	//			Com_Error( ERR_FATAL, "Error reading from journal file" );
+	//		}
+	//	}
+	//} else 
+	{
 		ev = Com_GetSystemEvent();
 
 		// write the journal value out if needed
-		if ( com_journal->integer == 1 ) {
+		/*if ( com_journal->integer == 1 ) {
 			r = FS_Write( &ev, sizeof(ev), com_journalFile );
 			if ( r != sizeof(ev) ) {
 				Com_Error( ERR_FATAL, "Error writing to journal file" );
@@ -2089,7 +2091,7 @@
 					Com_Error( ERR_FATAL, "Error writing to journal file" );
 				}
 			}
-		}
+		}*/
 	}
 
 	return ev;
@@ -2477,7 +2479,7 @@
 */
 qboolean CL_CDKeyValidate( const char *key, const char *checksum );
 void Com_ReadCDKey( const char *filename ) {
-	fileHandle_t	f;
+	vfsFileAPI_i *	f;
 	char			buffer[33];
 	char			fbuffer[MAX_OSPATH];
 
@@ -2507,7 +2509,7 @@
 =================
 */
 void Com_AppendCDKey( const char *filename ) {
-	fileHandle_t	f;
+	vfsFileAPI_i *	f;
 	char			buffer[33];
 	char			fbuffer[MAX_OSPATH];
 
@@ -2538,7 +2540,7 @@
 =================
 */
 static void Com_WriteCDKey( const char *filename, const char *ikey ) {
-	fileHandle_t	f;
+	vfsFileAPI_i *	f;
 	char			fbuffer[MAX_OSPATH];
 	char			key[17];
 #ifndef _WIN32
@@ -2936,11 +2938,11 @@
 	Com_Printf ("Altivec support is %s\n", com_altivec->integer ? "enabled" : "disabled");
 #endif
 
-	com_pipefile = Cvar_Get( "com_pipefile", "", CVAR_ARCHIVE|CVAR_LATCH );
-	if( com_pipefile->string[0] )
-	{
-		pipefile = FS_FCreateOpenPipeFile( com_pipefile->string );
-	}
+	//com_pipefile = Cvar_Get( "com_pipefile", "", CVAR_ARCHIVE|CVAR_LATCH );
+	//if( com_pipefile->string[0] )
+	//{
+	//	pipefile = FS_FCreateOpenPipeFile( com_pipefile->string );
+	//}
 
 	Com_Printf ("--- Common Initialization Complete ---\n");
 }
@@ -2999,7 +3001,7 @@
 //==================================================================
 
 void Com_WriteConfigToFile( const char *filename ) {
-	fileHandle_t	f;
+	vfsFileAPI_i *	f;
 
 	f = FS_FOpenFileWrite( filename );
 	if ( !f ) {
Index: code/qcommon/cvar.cpp
===================================================================
--- code/qcommon/cvar.cpp	(revision 183)
+++ code/qcommon/cvar.cpp	(working copy)
@@ -25,6 +25,7 @@
 #include "qcommon.h"
 #include <api/iFaceMgrAPI.h>
 #include <api/cvarAPI.h>
+#include <api/vfsAPI.h>
 #include <shared/cvarModificationCallback.h>
 #include <shared/autoCvar.h>
 
@@ -921,7 +922,7 @@
 with the archive flag set to qtrue.
 ============
 */
-void Cvar_WriteVariables(fileHandle_t f)
+void Cvar_WriteVariables(vfsFileAPI_i * f)
 {
 	cvar_s	*var;
 	char	buffer[1024];
@@ -948,7 +949,7 @@
 				}
 				Com_sprintf (buffer, sizeof(buffer), "seta %s \"%s\"\n", var->name, var->string);
 			}
-			FS_Write( buffer, strlen( buffer ), f );
+			f->writeData(buffer, strlen(buffer));
 		}
 	}
 }
Index: code/qcommon/files.cpp
===================================================================
--- code/qcommon/files.cpp	(revision 183)
+++ code/qcommon/files.cpp	(working copy)
@@ -1,3926 +1 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
-/*****************************************************************************
- * name:		files.c
- *
- * desc:		handle based filesystem for Quake III Arena 
- *
- * $Archive: /MissionPack/code/qcommon/files.c $
- *
- *****************************************************************************/
-
-
-#include "q_shared.h"
-#include "qcommon.h"
-#include "unzip.h"
-#include <api/iFaceMgrAPI.h>
-#include <api/vfsAPI.h>
-
-/*
-=============================================================================
-
-QUAKE3 FILESYSTEM
-
-All of Quake's data access is through a hierarchical file system, but the contents of 
-the file system can be transparently merged from several sources.
-
-A "qpath" is a reference to game file data.  MAX_ZPATH is 256 characters, which must include
-a terminating zero. "..", "\\", and ":" are explicitly illegal in qpaths to prevent any
-references outside the quake directory system.
-
-The "base path" is the path to the directory holding all the game directories and usually
-the executable.  It defaults to ".", but can be overridden with a "+set fs_basepath c:\quake3"
-command line to allow code debugging in a different directory.  Basepath cannot
-be modified at all after startup.  Any files that are created (demos, screenshots,
-etc) will be created relative to the base path, so base path should usually be writable.
-
-The "home path" is the path used for all write access. On win32 systems we have "base path"
-== "home path", but on *nix systems the base installation is usually readonly, and
-"home path" points to ~/.q3a or similar
-
-The user can also install custom mods and content in "home path", so it should be searched
-along with "home path" and "cd path" for game content.
-
-
-The "base game" is the directory under the paths where data comes from by default, and
-can be either "baseq3" or "demoq3".
-
-The "current game" may be the same as the base game, or it may be the name of another
-directory under the paths that should be searched for files before looking in the base game.
-This is the basis for addons.
-
-Clients automatically set the game directory after receiving a gamestate from a server,
-so only servers need to worry about +set fs_game.
-
-No other directories outside of the base game and current game will ever be referenced by
-filesystem functions.
-
-To save disk space and speed loading, directory trees can be collapsed into zip files.
-The files use a ".pk3" extension to prevent users from unzipping them accidentally, but
-otherwise the are simply normal uncompressed zip files.  A game directory can have multiple
-zip files of the form "pak0.pk3", "pak1.pk3", etc.  Zip files are searched in decending order
-from the highest number to the lowest, and will always take precedence over the filesystem.
-This allows a pk3 distributed as a patch to override all existing data.
-
-Because we will have updated executables freely available online, there is no point to
-trying to restrict demo / oem versions of the game with code changes.  Demo / oem versions
-should be exactly the same executables as release versions, but with different data that
-automatically restricts where game media can come from to prevent add-ons from working.
-
-File search order: when FS_FOpenFileRead gets called it will go through the fs_searchpaths
-structure and stop on the first successful hit. fs_searchpaths is built with successive
-calls to FS_AddGameDirectory
-
-Additionaly, we search in several subdirectories:
-current game is the current mode
-base game is a variable to allow mods based on other mods
-(such as baseq3 + missionpack content combination in a mod for instance)
-BASEGAME is the hardcoded base game ("baseq3")
-
-e.g. the qpath "sound/newstuff/test.wav" would be searched for in the following places:
-
-home path + current game's zip files
-home path + current game's directory
-base path + current game's zip files
-base path + current game's directory
-cd path + current game's zip files
-cd path + current game's directory
-
-home path + base game's zip file
-home path + base game's directory
-base path + base game's zip file
-base path + base game's directory
-cd path + base game's zip file
-cd path + base game's directory
-
-home path + BASEGAME's zip file
-home path + BASEGAME's directory
-base path + BASEGAME's zip file
-base path + BASEGAME's directory
-cd path + BASEGAME's zip file
-cd path + BASEGAME's directory
-
-server download, to be written to home path + current game's directory
-
-
-The filesystem can be safely shutdown and reinitialized with different
-basedir / cddir / game combinations, but all other subsystems that rely on it
-(sound, video) must also be forced to restart.
-
-Because the same files are loaded by both the clip model (CM_) and renderer (TR_)
-subsystems, a simple single-file caching scheme is used.  The CM_ subsystems will
-load the file with a request to cache.  Only one file will be kept cached at a time,
-so any models that are going to be referenced by both subsystems should alternate
-between the CM_ load function and the ref load function.
-
-TODO: A qpath that starts with a leading slash will always refer to the base game, even if another
-game is currently active.  This allows character models, skins, and sounds to be downloaded
-to a common directory no matter which game is active.
-
-How to prevent downloading zip files?
-Pass pk3 file names in systeminfo, and download before FS_Restart()?
-
-Aborting a download disconnects the client from the server.
-
-How to mark files as downloadable?  Commercial add-ons won't be downloadable.
-
-Non-commercial downloads will want to download the entire zip file.
-the game would have to be reset to actually read the zip in
-
-Auto-update information
-
-Path separators
-
-Casing
-
-  separate server gamedir and client gamedir, so if the user starts
-  a local game after having connected to a network game, it won't stick
-  with the network game.
-
-  allow menu options for game selection?
-
-Read / write config to floppy option.
-
-Different version coexistance?
-
-When building a pak file, make sure a q3config.cfg isn't present in it,
-or configs will never get loaded from disk!
-
-  todo:
-
-  downloading (outside fs?)
-  game directory passing and restarting
-
-=============================================================================
-
-*/
-
-// every time a new demo pk3 file is built, this checksum must be updated.
-// the easiest way to get it is to just run the game and see what it spits out
-#define	DEMO_PAK0_CHECKSUM	2985612116u
-static const unsigned int pak_checksums[] = {
-	1566731103u,
-	298122907u,
-	412165236u,
-	2991495316u,
-	1197932710u,
-	4087071573u,
-	3709064859u,
-	908855077u,
-	977125798u
-};
-
-static const unsigned int missionpak_checksums[] =
-{
-	2430342401u,
-	511014160u,
-	2662638993u,
-	1438664554u
-};
-
-// if this is defined, the executable positively won't work with any paks other
-// than the demo pak, even if productid is present.  This is only used for our
-// last demo release to prevent the mac and linux users from using the demo
-// executable with the production windows pak before the mac/linux products
-// hit the shelves a little later
-// NOW defined in build files
-//#define PRE_RELEASE_TADEMO
-
-#define MAX_ZPATH			256
-#define	MAX_SEARCH_PATHS	4096
-#define MAX_FILEHASH_SIZE	1024
-
-typedef struct fileInPack_s {
-	char					*name;		// name of the file
-	unsigned long			pos;		// file info position in zip
-	unsigned long			len;		// uncompress file size
-	struct	fileInPack_s*	next;		// next file in the hash
-} fileInPack_t;
-
-typedef struct {
-        char			pakPathname[MAX_OSPATH];	// c:\quake3\baseq3
-	char			pakFilename[MAX_OSPATH];	// c:\quake3\baseq3\pak0.pk3
-	char			pakBasename[MAX_OSPATH];	// pak0
-	char			pakGamename[MAX_OSPATH];	// baseq3
-	unzFile			handle;						// handle to zip file
-	int				checksum;					// regular checksum
-	int				pure_checksum;				// checksum for pure
-	int				numfiles;					// number of files in pk3
-	int				referenced;					// referenced file flags
-	int				hashSize;					// hash table size (power of 2)
-	fileInPack_t*	*hashTable;					// hash table
-	fileInPack_t*	buildBuffer;				// buffer with the filenames etc.
-} pack_t;
-
-typedef struct {
-	char		path[MAX_OSPATH];		// c:\quake3
-	char		fullpath[MAX_OSPATH];		// c:\quake3\baseq3
-	char		gamedir[MAX_OSPATH];	// baseq3
-} directory_t;
-
-typedef struct searchpath_s {
-	struct searchpath_s *next;
-
-	pack_t		*pack;		// only one of pack / dir will be non NULL
-	directory_t	*dir;
-} searchpath_t;
-
-static	char		fs_gamedir[MAX_OSPATH];	// this will be a single file name with no separators
-static	cvar_s		*fs_debug;
-static	cvar_s		*fs_homepath;
-
-#ifdef MACOS_X
-// Also search the .app bundle for .pk3 files
-static  cvar_s          *fs_apppath;
-#endif
-
-static	cvar_s		*fs_basepath;
-static	cvar_s		*fs_basegame;
-static	cvar_s		*fs_gamedirvar;
-static	searchpath_t	*fs_searchpaths;
-static	int			fs_readCount;			// total bytes read
-static	int			fs_loadCount;			// total files read
-static	int			fs_loadStack;			// total files in memory
-static	int			fs_packFiles = 0;		// total number of files in packs
-
-static int fs_checksumFeed;
-
-typedef union qfile_gus {
-	FILE*		o;
-	unzFile		z;
-} qfile_gut;
-
-typedef struct qfile_us {
-	qfile_gut	file;
-	qboolean	unique;
-} qfile_ut;
-
-typedef struct {
-	qfile_ut	handleFiles;
-	qboolean	handleSync;
-	int			baseOffset;
-	int			fileSize;
-	int			zipFilePos;
-	qboolean	zipFile;
-	qboolean	streamed;
-	char		name[MAX_ZPATH];
-} fileHandleData_t;
-
-static fileHandleData_t	fsh[MAX_FILE_HANDLES];
-
-// TTimo - https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=540
-// wether we did a reorder on the current search path when joining the server
-static qboolean fs_reordered;
-
-// never load anything from pk3 files that are not present at the server when pure
-static int		fs_numServerPaks = 0;
-static int		fs_serverPaks[MAX_SEARCH_PATHS];				// checksums
-static char		*fs_serverPakNames[MAX_SEARCH_PATHS];			// pk3 names
-
-// only used for autodownload, to make sure the client has at least
-// all the pk3 files that are referenced at the server side
-static int		fs_numServerReferencedPaks;
-static int		fs_serverReferencedPaks[MAX_SEARCH_PATHS];			// checksums
-static char		*fs_serverReferencedPakNames[MAX_SEARCH_PATHS];		// pk3 names
-
-// last valid game folder used
-char lastValidBase[MAX_OSPATH];
-char lastValidGame[MAX_OSPATH];
-
-#ifdef FS_MISSING
-FILE*		missingFiles = NULL;
-#endif
-
-/* C99 defines __func__ */
-#ifndef __func__
-#define __func__ "(unknown)"
-#endif
-
-/*
-==============
-FS_Initialized
-==============
-*/
-
-qboolean FS_Initialized( void ) {
-	return (fs_searchpaths != NULL);
-}
-
-/*
-=================
-FS_PakIsPure
-=================
-*/
-qboolean FS_PakIsPure( pack_t *pack ) {
-	int i;
-
-	if ( fs_numServerPaks ) {
-		for ( i = 0 ; i < fs_numServerPaks ; i++ ) {
-			// FIXME: also use hashed file names
-			// NOTE TTimo: a pk3 with same checksum but different name would be validated too
-			//   I don't see this as allowing for any exploit, it would only happen if the client does manips of its file names 'not a bug'
-			if ( pack->checksum == fs_serverPaks[i] ) {
-				return qtrue;		// on the aproved list
-			}
-		}
-		return qfalse;	// not on the pure server pak list
-	}
-	return qtrue;
-}
-
-
-/*
-=================
-FS_LoadStack
-return load stack
-=================
-*/
-int FS_LoadStack( void )
-{
-	return fs_loadStack;
-}
-
-/*
-================
-return a hash value for the filename
-================
-*/
-static long FS_HashFileName( const char *fname, int hashSize ) {
-	int		i;
-	long	hash;
-	char	letter;
-
-	hash = 0;
-	i = 0;
-	while (fname[i] != '\0') {
-		letter = tolower(fname[i]);
-		if (letter =='.') break;				// don't include extension
-		if (letter =='\\') letter = '/';		// damn path names
-		if (letter == PATH_SEP) letter = '/';		// damn path names
-		hash+=(long)(letter)*(i+119);
-		i++;
-	}
-	hash = (hash ^ (hash >> 10) ^ (hash >> 20));
-	hash &= (hashSize-1);
-	return hash;
-}
-
-static fileHandle_t	FS_HandleForFile(void) {
-	int		i;
-
-	for ( i = 1 ; i < MAX_FILE_HANDLES ; i++ ) {
-		if ( fsh[i].handleFiles.file.o == NULL ) {
-			return i;
-		}
-	}
-	Com_Error( ERR_DROP, "FS_HandleForFile: none free" );
-	return 0;
-}
-
-static FILE	*FS_FileForHandle( fileHandle_t f ) {
-	if ( f < 1 || f > MAX_FILE_HANDLES ) {
-		Com_Error( ERR_DROP, "FS_FileForHandle: out of range" );
-	}
-	if (fsh[f].zipFile == qtrue) {
-		Com_Error( ERR_DROP, "FS_FileForHandle: can't get FILE on zip file" );
-	}
-	if ( ! fsh[f].handleFiles.file.o ) {
-		Com_Error( ERR_DROP, "FS_FileForHandle: NULL" );
-	}
-	
-	return fsh[f].handleFiles.file.o;
-}
-
-void	FS_ForceFlush( fileHandle_t f ) {
-	FILE *file;
-
-	file = FS_FileForHandle(f);
-	setvbuf( file, NULL, _IONBF, 0 );
-}
-
-/*
-================
-FS_fplength
-================
-*/
-
-long FS_fplength(FILE *h)
-{
-	long		pos;
-	long		end;
-
-	pos = ftell(h);
-	fseek(h, 0, SEEK_END);
-	end = ftell(h);
-	fseek(h, pos, SEEK_SET);
-
-	return end;
-}
-
-/*
-================
-FS_filelength
-
-If this is called on a non-unique FILE (from a pak file),
-it will return the size of the pak file, not the expected
-size of the file.
-================
-*/
-long FS_filelength(fileHandle_t f)
-{
-	FILE	*h;
-
-	h = FS_FileForHandle(f);
-	
-	if(h == NULL)
-	        return -1;
-        else
-	        return FS_fplength(h);
-}
-
-/*
-====================
-FS_ReplaceSeparators
-
-Fix things up differently for win/unix/mac
-====================
-*/
-static void FS_ReplaceSeparators( char *path ) {
-	char	*s;
-	qboolean lastCharWasSep = qfalse;
-
-	for ( s = path ; *s ; s++ ) {
-		if ( *s == '/' || *s == '\\' ) {
-			if ( !lastCharWasSep ) {
-				*s = PATH_SEP;
-				lastCharWasSep = qtrue;
-			} else {
-				memmove (s, s + 1, strlen (s));
-			}
-		} else {
-			lastCharWasSep = qfalse;
-		}
-	}
-}
-
-/*
-===================
-FS_BuildOSPath
-
-Qpath may have either forward or backwards slashes
-===================
-*/
-char *FS_BuildOSPath( const char *base, const char *game, const char *qpath ) {
-	char	temp[MAX_OSPATH];
-	static char ospath[2][MAX_OSPATH];
-	static int toggle;
-	
-	toggle ^= 1;		// flip-flop to allow two returns without clash
-
-	if( !game || !game[0] ) {
-		game = fs_gamedir;
-	}
-
-	Com_sprintf( temp, sizeof(temp), "/%s/%s", game, qpath );
-	FS_ReplaceSeparators( temp );
-	Com_sprintf( ospath[toggle], sizeof( ospath[0] ), "%s%s", base, temp );
-	
-	return ospath[toggle];
-}
-
-
-/*
-============
-FS_CreatePath
-
-Creates any directories needed to store the given filename
-============
-*/
-qboolean FS_CreatePath (char *OSPath) {
-	char	*ofs;
-	char	path[MAX_OSPATH];
-	
-	// make absolutely sure that it can't back up the path
-	// FIXME: is c: allowed???
-	if ( strstr( OSPath, ".." ) || strstr( OSPath, "::" ) ) {
-		Com_Printf( "WARNING: refusing to create relative path \"%s\"\n", OSPath );
-		return qtrue;
-	}
-
-	Q_strncpyz( path, OSPath, sizeof( path ) );
-	FS_ReplaceSeparators( path );
-
-	// Skip creation of the root directory as it will always be there
-	ofs = strchr( path, PATH_SEP );
-	ofs++;
-
-	for (; ofs != NULL && *ofs ; ofs++) {
-		if (*ofs == PATH_SEP) {
-			// create the directory
-			*ofs = 0;
-			if (!Sys_Mkdir (path)) {
-				Com_Error( ERR_FATAL, "FS_CreatePath: failed to create path \"%s\"",
-					path );
-			}
-			*ofs = PATH_SEP;
-		}
-	}
-
-	return qfalse;
-}
-
-/*
-=================
-FS_CheckFilenameIsNotExecutable
-
-ERR_FATAL if trying to maniuplate a file with the platform library extension
-=================
- */
-static void FS_CheckFilenameIsNotExecutable( const char *filename,
-		const char *function )
-{
-	// Check if the filename ends with the library extension
-	if(COM_CompareExtension(filename, DLL_EXT))
-	{
-		Com_Error( ERR_FATAL, "%s: Not allowed to manipulate '%s' due "
-			"to %s extension", function, filename, DLL_EXT );
-	}
-}
-
-/*
-===========
-FS_Remove
-
-===========
-*/
-void FS_Remove( const char *osPath ) {
-	FS_CheckFilenameIsNotExecutable( osPath, __func__ );
-
-	remove( osPath );
-}
-
-/*
-===========
-FS_HomeRemove
-
-===========
-*/
-void FS_HomeRemove( const char *homePath ) {
-	FS_CheckFilenameIsNotExecutable( homePath, __func__ );
-
-	remove( FS_BuildOSPath( fs_homepath->string,
-			fs_gamedir, homePath ) );
-}
-
-/*
-================
-FS_FileInPathExists
-
-Tests if path and file exists
-================
-*/
-qboolean FS_FileInPathExists(const char *testpath)
-{
-	FILE *filep;
-
-	filep = fopen(testpath, "rb");
-	
-	if(filep)
-	{
-		fclose(filep);
-		return qtrue;
-	}
-	
-	return qfalse;
-}
-
-/*
-================
-FS_FileExists
-
-Tests if the file exists in the current gamedir, this DOES NOT
-search the paths.  This is to determine if opening a file to write
-(which always goes into the current gamedir) will cause any overwrites.
-NOTE TTimo: this goes with FS_FOpenFileWrite for opening the file afterwards
-================
-*/
-qboolean FS_FileExists(const char *file)
-{
-	return FS_FileInPathExists(FS_BuildOSPath(fs_homepath->string, fs_gamedir, file));
-}
-
-/*
-================
-FS_SV_FileExists
-
-Tests if the file exists 
-================
-*/
-qboolean FS_SV_FileExists( const char *file )
-{
-	char *testpath;
-
-	testpath = FS_BuildOSPath( fs_homepath->string, file, "");
-	testpath[strlen(testpath)-1] = '\0';
-
-	return FS_FileInPathExists(testpath);
-}
-
-
-/*
-===========
-FS_SV_FOpenFileWrite
-
-===========
-*/
-fileHandle_t FS_SV_FOpenFileWrite( const char *filename ) {
-	char *ospath;
-	fileHandle_t	f;
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	ospath = FS_BuildOSPath( fs_homepath->string, filename, "" );
-	ospath[strlen(ospath)-1] = '\0';
-
-	f = FS_HandleForFile();
-	fsh[f].zipFile = qfalse;
-
-	if ( fs_debug->integer ) {
-		Com_Printf( "FS_SV_FOpenFileWrite: %s\n", ospath );
-	}
-
-	FS_CheckFilenameIsNotExecutable( ospath, __func__ );
-
-	if( FS_CreatePath( ospath ) ) {
-		return 0;
-	}
-
-	Com_DPrintf( "writing to: %s\n", ospath );
-	fsh[f].handleFiles.file.o = fopen( ospath, "wb" );
-
-	Q_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );
-
-	fsh[f].handleSync = qfalse;
-	if (!fsh[f].handleFiles.file.o) {
-		f = 0;
-	}
-	return f;
-}
-
-/*
-===========
-FS_SV_FOpenFileRead
-
-Search for a file somewhere below the home path then base path
-in that order
-===========
-*/
-long FS_SV_FOpenFileRead(const char *filename, fileHandle_t *fp)
-{
-	char *ospath;
-	fileHandle_t	f = 0;
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	f = FS_HandleForFile();
-	fsh[f].zipFile = qfalse;
-
-	Q_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );
-
-	// don't let sound stutter
-	//S_ClearSoundBuffer();
-
-	// search homepath
-	ospath = FS_BuildOSPath( fs_homepath->string, filename, "" );
-	// remove trailing slash
-	ospath[strlen(ospath)-1] = '\0';
-
-	if ( fs_debug->integer ) {
-		Com_Printf( "FS_SV_FOpenFileRead (fs_homepath): %s\n", ospath );
-	}
-
-	fsh[f].handleFiles.file.o = fopen( ospath, "rb" );
-	fsh[f].handleSync = qfalse;
-	if (!fsh[f].handleFiles.file.o)
-	{
-		// If fs_homepath == fs_basepath, don't bother
-		if (Q_stricmp(fs_homepath->string,fs_basepath->string))
-		{
-			// search basepath
-			ospath = FS_BuildOSPath( fs_basepath->string, filename, "" );
-			ospath[strlen(ospath)-1] = '\0';
-
-			if ( fs_debug->integer )
-			{
-				Com_Printf( "FS_SV_FOpenFileRead (fs_basepath): %s\n", ospath );
-			}
-
-			fsh[f].handleFiles.file.o = fopen( ospath, "rb" );
-			fsh[f].handleSync = qfalse;
-		}
-
-		if ( !fsh[f].handleFiles.file.o )
-		{
-			f = 0;
-		}
-	}
-
-	*fp = f;
-	if (f) {
-		return FS_filelength(f);
-	}
-
-	return -1;
-}
-
-
-/*
-===========
-FS_SV_Rename
-
-===========
-*/
-void FS_SV_Rename( const char *from, const char *to ) {
-	char			*from_ospath, *to_ospath;
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	// don't let sound stutter
-	//S_ClearSoundBuffer();
-
-	from_ospath = FS_BuildOSPath( fs_homepath->string, from, "" );
-	to_ospath = FS_BuildOSPath( fs_homepath->string, to, "" );
-	from_ospath[strlen(from_ospath)-1] = '\0';
-	to_ospath[strlen(to_ospath)-1] = '\0';
-
-	if ( fs_debug->integer ) {
-		Com_Printf( "FS_SV_Rename: %s --> %s\n", from_ospath, to_ospath );
-	}
-
-	FS_CheckFilenameIsNotExecutable( to_ospath, __func__ );
-
-	rename(from_ospath, to_ospath);
-}
-
-
-
-/*
-===========
-FS_Rename
-
-===========
-*/
-void FS_Rename( const char *from, const char *to ) {
-	char			*from_ospath, *to_ospath;
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	// don't let sound stutter
-	//S_ClearSoundBuffer();
-
-	from_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, from );
-	to_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, to );
-
-	if ( fs_debug->integer ) {
-		Com_Printf( "FS_Rename: %s --> %s\n", from_ospath, to_ospath );
-	}
-
-	FS_CheckFilenameIsNotExecutable( to_ospath, __func__ );
-
-	rename(from_ospath, to_ospath);
-}
-
-/*
-==============
-FS_FCloseFile
-
-If the FILE pointer is an open pak file, leave it open.
-
-For some reason, other dll's can't just cal fclose()
-on files returned by FS_FOpenFile...
-==============
-*/
-void FS_FCloseFile( fileHandle_t f ) {
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	if (fsh[f].zipFile == qtrue) {
-		unzCloseCurrentFile( fsh[f].handleFiles.file.z );
-		if ( fsh[f].handleFiles.unique ) {
-			unzClose( fsh[f].handleFiles.file.z );
-		}
-		Com_Memset( &fsh[f], 0, sizeof( fsh[f] ) );
-		return;
-	}
-
-	// we didn't find it as a pak, so close it as a unique file
-	if (fsh[f].handleFiles.file.o) {
-		fclose (fsh[f].handleFiles.file.o);
-	}
-	Com_Memset( &fsh[f], 0, sizeof( fsh[f] ) );
-}
-
-/*
-===========
-FS_FOpenFileWrite
-
-===========
-*/
-fileHandle_t FS_FOpenFileWrite( const char *filename ) {
-	char			*ospath;
-	fileHandle_t	f;
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	f = FS_HandleForFile();
-	fsh[f].zipFile = qfalse;
-
-	ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename );
-
-	if ( fs_debug->integer ) {
-		Com_Printf( "FS_FOpenFileWrite: %s\n", ospath );
-	}
-
-	FS_CheckFilenameIsNotExecutable( ospath, __func__ );
-
-	if( FS_CreatePath( ospath ) ) {
-		return 0;
-	}
-
-	// enabling the following line causes a recursive function call loop
-	// when running with +set logfile 1 +set developer 1
-	//Com_DPrintf( "writing to: %s\n", ospath );
-	fsh[f].handleFiles.file.o = fopen( ospath, "wb" );
-
-	Q_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );
-
-	fsh[f].handleSync = qfalse;
-	if (!fsh[f].handleFiles.file.o) {
-		f = 0;
-	}
-	return f;
-}
-
-/*
-===========
-FS_FOpenFileAppend
-
-===========
-*/
-fileHandle_t FS_FOpenFileAppend( const char *filename ) {
-	char			*ospath;
-	fileHandle_t	f;
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	f = FS_HandleForFile();
-	fsh[f].zipFile = qfalse;
-
-	Q_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );
-
-	// don't let sound stutter
-	//S_ClearSoundBuffer();
-
-	ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename );
-
-	if ( fs_debug->integer ) {
-		Com_Printf( "FS_FOpenFileAppend: %s\n", ospath );
-	}
-
-	FS_CheckFilenameIsNotExecutable( ospath, __func__ );
-
-	if( FS_CreatePath( ospath ) ) {
-		return 0;
-	}
-
-	fsh[f].handleFiles.file.o = fopen( ospath, "ab" );
-	fsh[f].handleSync = qfalse;
-	if (!fsh[f].handleFiles.file.o) {
-		f = 0;
-	}
-	return f;
-}
-
-/*
-===========
-FS_FCreateOpenPipeFile
-
-===========
-*/
-fileHandle_t FS_FCreateOpenPipeFile( const char *filename ) {
-	char	    		*ospath;
-	FILE					*fifo;
-	fileHandle_t	f;
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	f = FS_HandleForFile();
-	fsh[f].zipFile = qfalse;
-
-	Q_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );
-
-	// don't let sound stutter
-	//S_ClearSoundBuffer();
-
-	ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename );
-
-	if ( fs_debug->integer ) {
-		Com_Printf( "FS_FCreateOpenPipeFile: %s\n", ospath );
-	}
-
-	FS_CheckFilenameIsNotExecutable( ospath, __func__ );
-
-	fifo = Sys_Mkfifo( ospath );
-	if( fifo ) {
-		fsh[f].handleFiles.file.o = fifo;
-		fsh[f].handleSync = qfalse;
-	}
-	else
-	{
-		Com_Printf( S_COLOR_YELLOW "WARNING: Could not create new com_pipefile at %s. "
-			"com_pipefile will not be used.\n", ospath );
-		f = 0;
-	}
-
-	return f;
-}
-
-/*
-===========
-FS_FilenameCompare
-
-Ignore case and seprator char distinctions
-===========
-*/
-qboolean FS_FilenameCompare( const char *s1, const char *s2 ) {
-	int		c1, c2;
-	
-	do {
-		c1 = *s1++;
-		c2 = *s2++;
-
-		if (c1 >= 'a' && c1 <= 'z') {
-			c1 -= ('a' - 'A');
-		}
-		if (c2 >= 'a' && c2 <= 'z') {
-			c2 -= ('a' - 'A');
-		}
-
-		if ( c1 == '\\' || c1 == ':' ) {
-			c1 = '/';
-		}
-		if ( c2 == '\\' || c2 == ':' ) {
-			c2 = '/';
-		}
-		
-		if (c1 != c2) {
-			return qtrue;		// strings not equal
-		}
-	} while (c1);
-	
-	return qfalse;		// strings are equal
-}
-
-/*
-===========
-FS_IsExt
-
-Return qtrue if ext matches file extension filename
-===========
-*/
-
-qboolean FS_IsExt(const char *filename, const char *ext, int namelen)
-{
-	int extlen;
-
-	extlen = strlen(ext);
-
-	if(extlen > namelen)
-		return qfalse;
-
-	filename += namelen - extlen;
-
-	return !Q_stricmp(filename, ext);
-}
-
-/*
-===========
-FS_IsDemoExt
-
-Return qtrue if filename has a demo extension
-===========
-*/
-
-qboolean FS_IsDemoExt(const char *filename, int namelen)
-{
-	const char *ext_test;
-	int index, protocol;
-
-	ext_test = strrchr(filename, '.');
-	if(ext_test && !Q_stricmpn(ext_test + 1, DEMOEXT, ARRAY_LEN(DEMOEXT) - 1))
-	{
-		protocol = atoi(ext_test + ARRAY_LEN(DEMOEXT));
-
-		if(protocol == com_protocol->integer)
-			return qtrue;
-
-#ifdef LEGACY_PROTOCOL
-                if(protocol == com_legacyprotocol->integer)
-                        return qtrue;
-#endif
-
-		for(index = 0; demo_protocols[index]; index++)
-		{
-			if(demo_protocols[index] == protocol)
-			return qtrue;
-		}
-	}
-
-	return qfalse;
-}
-
-/*
-===========
-FS_FOpenFileReadDir
-
-Tries opening file "filename" in searchpath "search"
-Returns filesize and an open FILE pointer.
-===========
-*/
-extern qboolean		com_fullyInitialized;
-
-long FS_FOpenFileReadDir(const char *filename, searchpath_t *search, fileHandle_t *file, qboolean uniqueFILE, qboolean unpure)
-{
-	long			hash;
-	pack_t		*pak;
-	fileInPack_t	*pakFile;
-	directory_t	*dir;
-	char		*netpath;
-	FILE		*filep;
-	int			len;
-
-	if(filename == NULL)
-		Com_Error(ERR_FATAL, "FS_FOpenFileRead: NULL 'filename' parameter passed");
-
-	// qpaths are not supposed to have a leading slash
-	if(filename[0] == '/' || filename[0] == '\\')
-		filename++;
-
-	// make absolutely sure that it can't back up the path.
-	// The searchpaths do guarantee that something will always
-	// be prepended, so we don't need to worry about "c:" or "//limbo" 
-	if(strstr(filename, ".." ) || strstr(filename, "::"))
-	{
-	        if(file == NULL)
-	                return qfalse;
-	                
-		*file = 0;
-		return -1;
-	}
-        
-	// make sure the q3key file is only readable by the quake3.exe at initialization
-	// any other time the key should only be accessed in memory using the provided functions
-	if(com_fullyInitialized && strstr(filename, "q3key"))
-	{
-	        if(file == NULL)
-	                return qfalse;
-
-		*file = 0;
-		return -1;
-	}
-
-	if(file == NULL)
-	{
-		// just wants to see if file is there
-
-		// is the element a pak file?
-		if(search->pack)
-		{
-			hash = FS_HashFileName(filename, search->pack->hashSize);
-                        
-                        if(search->pack->hashTable[hash])
-                        {
-				// look through all the pak file elements
-				pak = search->pack;
-				pakFile = pak->hashTable[hash];
-
-				do
-				{
-					// case and separator insensitive comparisons
-					if(!FS_FilenameCompare(pakFile->name, filename))
-					{
-						// found it!
-						if(pakFile->len)
-        						return pakFile->len;
-                                                else
-                                                {
-                                                        // It's not nice, but legacy code depends
-                                                        // on positive value if file exists no matter
-                                                        // what size
-                                                        return 1;
-                                                }
-					}
-
-					pakFile = pakFile->next;
-				} while(pakFile != NULL);
-			}
-		}
-		else if(search->dir)
-		{
-			dir = search->dir;
-		
-			netpath = FS_BuildOSPath(dir->path, dir->gamedir, filename);
-			filep = fopen (netpath, "rb");
-
-			if(filep)
-			{
-			        len = FS_fplength(filep);
-				fclose(filep);
-				
-				if(len)
-        				return len;
-                                else
-                                        return 1;
-			}
-		}
-		
-		return 0;
-	}
-
-	*file = FS_HandleForFile();
-	fsh[*file].handleFiles.unique = uniqueFILE;
-	
-	// is the element a pak file?
-	if(search->pack)
-	{
-		hash = FS_HashFileName(filename, search->pack->hashSize);
-
-		if(search->pack->hashTable[hash])
-		{
-			// disregard if it doesn't match one of the allowed pure pak files
-			if(!unpure && !FS_PakIsPure(search->pack))
-			{
-				*file = 0;
-				return -1;
-			}
-
-			// look through all the pak file elements
-			pak = search->pack;
-			pakFile = pak->hashTable[hash];
-		
-			do
-			{
-				// case and separator insensitive comparisons
-				if(!FS_FilenameCompare(pakFile->name, filename))
-				{
-					// found it!
-
-					// mark the pak as having been referenced and mark specifics on cgame and ui
-					// shaders, txt, arena files  by themselves do not count as a reference as 
-					// these are loaded from all pk3s 
-					// from every pk3 file.. 
-					len = strlen(filename);
-
-					if (!(pak->referenced & FS_GENERAL_REF))
-					{
-						if(!FS_IsExt(filename, ".shader", len) &&
-						   !FS_IsExt(filename, ".txt", len) &&
-						   !FS_IsExt(filename, ".cfg", len) &&
-						   !FS_IsExt(filename, ".config", len) &&
-						   !FS_IsExt(filename, ".bot", len) &&
-						   !FS_IsExt(filename, ".arena", len) &&
-						   !FS_IsExt(filename, ".menu", len) &&
-						   Q_stricmp(filename, "qagame.qvm") != 0 &&
-						   !strstr(filename, "levelshots"))
-						{
-							pak->referenced |= FS_GENERAL_REF;
-						}
-					}
-
-					if(strstr(filename, "cgame.qvm"))
-						pak->referenced |= FS_CGAME_REF;
-					if(strstr(filename, "ui.qvm"))
-						pak->referenced |= FS_UI_REF;
-
-					if(uniqueFILE)
-					{
-						// open a new file on the pakfile
-						fsh[*file].handleFiles.file.z = unzOpen(pak->pakFilename);
-					
-						if(fsh[*file].handleFiles.file.z == NULL)
-							Com_Error(ERR_FATAL, "Couldn't open %s", pak->pakFilename);
-					}
-					else
-						fsh[*file].handleFiles.file.z = pak->handle;
-
-					Q_strncpyz(fsh[*file].name, filename, sizeof(fsh[*file].name));
-					fsh[*file].zipFile = qtrue;
-				
-					// set the file position in the zip file (also sets the current file info)
-					unzSetOffset(fsh[*file].handleFiles.file.z, pakFile->pos);
-
-					// open the file in the zip
-					unzOpenCurrentFile(fsh[*file].handleFiles.file.z);
-					fsh[*file].zipFilePos = pakFile->pos;
-
-					if(fs_debug->integer)
-					{
-						Com_Printf("FS_FOpenFileRead: %s (found in '%s')\n", 
-							filename, pak->pakFilename);
-					}
-				
-					return pakFile->len;
-				}
-			
-				pakFile = pakFile->next;
-			} while(pakFile != NULL);
-		}
-	}
-	else if(search->dir)
-	{
-		// check a file in the directory tree
-
-		// if we are running restricted, the only files we
-		// will allow to come from the directory are .cfg files
-		len = strlen(filename);
-		// FIXME TTimo I'm not sure about the fs_numServerPaks test
-		// if you are using FS_ReadFile to find out if a file exists,
-		//   this test can make the search fail although the file is in the directory
-		// I had the problem on https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=8
-		// turned out I used FS_FileExists instead
-		if(!unpure && fs_numServerPaks)
-		{
-			if(!FS_IsExt(filename, ".cfg", len) &&		// for config files
-			   !FS_IsExt(filename, ".menu", len) &&		// menu files
-			   !FS_IsExt(filename, ".game", len) &&		// menu files
-			   !FS_IsExt(filename, ".dat", len) &&		// for journal files
-			   !FS_IsDemoExt(filename, len))			// demos
-			{
-				*file = 0;
-				return -1;
-			}
-		}
-
-		dir = search->dir;
-
-		netpath = FS_BuildOSPath(dir->path, dir->gamedir, filename);
-		filep = fopen(netpath, "rb");
-
-		if (filep == NULL)
-		{
-			*file = 0;
-                        return -1;
-		}
-
-		Q_strncpyz(fsh[*file].name, filename, sizeof(fsh[*file].name));
-		fsh[*file].zipFile = qfalse;
-		
-		if(fs_debug->integer)
-		{
-			Com_Printf("FS_FOpenFileRead: %s (found in '%s/%s')\n", filename,
-				dir->path, dir->gamedir);
-		}
-
-		fsh[*file].handleFiles.file.o = filep;
-		return FS_fplength(filep);
-	}
-
-	return -1;
-}
-
-/*
-===========
-FS_FOpenFileRead
-
-Finds the file in the search path.
-Returns filesize and an open FILE pointer.
-Used for streaming data out of either a
-separate file or a ZIP file.
-===========
-*/
-long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueFILE)
-{
-	searchpath_t *search;
-	long len;
-
-	if(!fs_searchpaths)
-		Com_Error(ERR_FATAL, "Filesystem call made without initialization");
-
-	for(search = fs_searchpaths; search; search = search->next)
-	{
-	        len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);
-	        
-	        if(file == NULL)
-	        {
-	                if(len > 0)
-	                        return len;
-	        }
-	        else
-	        {
-	                if(len >= 0 && *file)
-	                        return len;
-	        }
-	        
-	}
-	
-#ifdef FS_MISSING
-	if(missingFiles)
-		fprintf(missingFiles, "%s\n", filename);
-#endif
-
-        if(file)
-        	*file = 0;
-        	
-	return -1;
-}
-
-/*
-=================
-FS_Read
-
-Properly handles partial reads
-=================
-*/
-int FS_Read2( void *buffer, int len, fileHandle_t f ) {
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	if ( !f ) {
-		return 0;
-	}
-	if (fsh[f].streamed) {
-		int r;
-		fsh[f].streamed = qfalse;
-		r = FS_Read( buffer, len, f );
-		fsh[f].streamed = qtrue;
-		return r;
-	} else {
-		return FS_Read( buffer, len, f);
-	}
-}
-
-int FS_Read( void *buffer, int len, fileHandle_t f ) {
-	int		block, remaining;
-	int		read;
-	byte	*buf;
-	int		tries;
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	if ( !f ) {
-		return 0;
-	}
-
-	buf = (byte *)buffer;
-	fs_readCount += len;
-
-	if (fsh[f].zipFile == qfalse) {
-		remaining = len;
-		tries = 0;
-		while (remaining) {
-			block = remaining;
-			read = fread (buf, 1, block, fsh[f].handleFiles.file.o);
-			if (read == 0) {
-				// we might have been trying to read from a CD, which
-				// sometimes returns a 0 read on windows
-				if (!tries) {
-					tries = 1;
-				} else {
-					return len-remaining;	//Com_Error (ERR_FATAL, "FS_Read: 0 bytes read");
-				}
-			}
-
-			if (read == -1) {
-				Com_Error (ERR_FATAL, "FS_Read: -1 bytes read");
-			}
-
-			remaining -= read;
-			buf += read;
-		}
-		return len;
-	} else {
-		return unzReadCurrentFile(fsh[f].handleFiles.file.z, buffer, len);
-	}
-}
-
-/*
-=================
-FS_Write
-
-Properly handles partial writes
-=================
-*/
-int FS_Write( const void *buffer, int len, fileHandle_t h ) {
-	int		block, remaining;
-	int		written;
-	byte	*buf;
-	int		tries;
-	FILE	*f;
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	if ( !h ) {
-		return 0;
-	}
-
-	f = FS_FileForHandle(h);
-	buf = (byte *)buffer;
-
-	remaining = len;
-	tries = 0;
-	while (remaining) {
-		block = remaining;
-		written = fwrite (buf, 1, block, f);
-		if (written == 0) {
-			if (!tries) {
-				tries = 1;
-			} else {
-				Com_Printf( "FS_Write: 0 bytes written\n" );
-				return 0;
-			}
-		}
-
-		if (written == -1) {
-			Com_Printf( "FS_Write: -1 bytes written\n" );
-			return 0;
-		}
-
-		remaining -= written;
-		buf += written;
-	}
-	if ( fsh[h].handleSync ) {
-		fflush( f );
-	}
-	return len;
-}
-
-void QDECL FS_Printf( fileHandle_t h, const char *fmt, ... ) {
-	va_list		argptr;
-	char		msg[MAXPRINTMSG];
-
-	va_start (argptr,fmt);
-	Q_vsnprintf (msg, sizeof(msg), fmt, argptr);
-	va_end (argptr);
-
-	FS_Write(msg, strlen(msg), h);
-}
-
-#define PK3_SEEK_BUFFER_SIZE 65536
-
-/*
-=================
-FS_Seek
-
-=================
-*/
-int FS_Seek( fileHandle_t f, long offset, int origin ) {
-	int		_origin;
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-		return -1;
-	}
-
-	if (fsh[f].streamed) {
-		fsh[f].streamed = qfalse;
-	 	FS_Seek( f, offset, origin );
-		fsh[f].streamed = qtrue;
-	}
-
-	if (fsh[f].zipFile == qtrue) {
-		//FIXME: this is incomplete and really, really
-		//crappy (but better than what was here before)
-		byte	buffer[PK3_SEEK_BUFFER_SIZE];
-		int		remainder = offset;
-
-		if( offset < 0 || origin == FS_SEEK_END ) {
-			Com_Error( ERR_FATAL, "Negative offsets and FS_SEEK_END not implemented "
-					"for FS_Seek on pk3 file contents" );
-			return -1;
-		}
-
-		switch( origin ) {
-			case FS_SEEK_SET:
-				unzSetOffset(fsh[f].handleFiles.file.z, fsh[f].zipFilePos);
-				unzOpenCurrentFile(fsh[f].handleFiles.file.z);
-				//fallthrough
-
-			case FS_SEEK_CUR:
-				while( remainder > PK3_SEEK_BUFFER_SIZE ) {
-					FS_Read( buffer, PK3_SEEK_BUFFER_SIZE, f );
-					remainder -= PK3_SEEK_BUFFER_SIZE;
-				}
-				FS_Read( buffer, remainder, f );
-				return offset;
-				break;
-
-			default:
-				Com_Error( ERR_FATAL, "Bad origin in FS_Seek" );
-				return -1;
-				break;
-		}
-	} else {
-		FILE *file;
-		file = FS_FileForHandle(f);
-		switch( origin ) {
-		case FS_SEEK_CUR:
-			_origin = SEEK_CUR;
-			break;
-		case FS_SEEK_END:
-			_origin = SEEK_END;
-			break;
-		case FS_SEEK_SET:
-			_origin = SEEK_SET;
-			break;
-		default:
-			_origin = SEEK_CUR;
-			Com_Error( ERR_FATAL, "Bad origin in FS_Seek" );
-			break;
-		}
-
-		return fseek( file, offset, _origin );
-	}
-}
-
-
-/*
-======================================================================================
-
-CONVENIENCE FUNCTIONS FOR ENTIRE FILES
-
-======================================================================================
-*/
-
-int	FS_FileIsInPAK(const char *filename, int *pChecksum ) {
-	searchpath_t	*search;
-	pack_t			*pak;
-	fileInPack_t	*pakFile;
-	long			hash = 0;
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	if ( !filename ) {
-		Com_Error( ERR_FATAL, "FS_FOpenFileRead: NULL 'filename' parameter passed" );
-	}
-
-	// qpaths are not supposed to have a leading slash
-	if ( filename[0] == '/' || filename[0] == '\\' ) {
-		filename++;
-	}
-
-	// make absolutely sure that it can't back up the path.
-	// The searchpaths do guarantee that something will always
-	// be prepended, so we don't need to worry about "c:" or "//limbo" 
-	if ( strstr( filename, ".." ) || strstr( filename, "::" ) ) {
-		return -1;
-	}
-
-	//
-	// search through the path, one element at a time
-	//
-
-	for ( search = fs_searchpaths ; search ; search = search->next ) {
-		//
-		if (search->pack) {
-			hash = FS_HashFileName(filename, search->pack->hashSize);
-		}
-		// is the element a pak file?
-		if ( search->pack && search->pack->hashTable[hash] ) {
-			// disregard if it doesn't match one of the allowed pure pak files
-			if ( !FS_PakIsPure(search->pack) ) {
-				continue;
-			}
-
-			// look through all the pak file elements
-			pak = search->pack;
-			pakFile = pak->hashTable[hash];
-			do {
-				// case and separator insensitive comparisons
-				if ( !FS_FilenameCompare( pakFile->name, filename ) ) {
-					if (pChecksum) {
-						*pChecksum = pak->pure_checksum;
-					}
-					return 1;
-				}
-				pakFile = pakFile->next;
-			} while(pakFile != NULL);
-		}
-	}
-	return -1;
-}
-
-/*
-============
-FS_ReadFileDir
-
-Filename are relative to the quake search path
-a null buffer will just return the file length without loading
-If searchPath is non-NULL search only in that specific search path
-============
-*/
-long FS_ReadFileDir(const char *qpath, void *searchPath, qboolean unpure, void **buffer)
-{
-	fileHandle_t	h;
-	searchpath_t	*search;
-	byte*			buf;
-	qboolean		isConfig;
-	long				len;
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	if ( !qpath || !qpath[0] ) {
-		Com_Error( ERR_FATAL, "FS_ReadFile with empty name" );
-	}
-
-	buf = NULL;	// quiet compiler warning
-
-	// if this is a .cfg file and we are playing back a journal, read
-	// it from the journal file
-	if ( strstr( qpath, ".cfg" ) ) {
-		isConfig = qtrue;
-		if ( com_journal && com_journal->integer == 2 ) {
-			int		r;
-
-			Com_DPrintf( "Loading %s from journal file.\n", qpath );
-			r = FS_Read( &len, sizeof( len ), com_journalDataFile );
-			if ( r != sizeof( len ) ) {
-				if (buffer != NULL) *buffer = NULL;
-				return -1;
-			}
-			// if the file didn't exist when the journal was created
-			if (!len) {
-				if (buffer == NULL) {
-					return 1;			// hack for old journal files
-				}
-				*buffer = NULL;
-				return -1;
-			}
-			if (buffer == NULL) {
-				return len;
-			}
-
-			buf = (byte*)Hunk_AllocateTempMemory(len+1);
-			*buffer = buf;
-
-			r = FS_Read( buf, len, com_journalDataFile );
-			if ( r != len ) {
-				Com_Error( ERR_FATAL, "Read from journalDataFile failed" );
-			}
-
-			fs_loadCount++;
-			fs_loadStack++;
-
-			// guarantee that it will have a trailing 0 for string operations
-			buf[len] = 0;
-
-			return len;
-		}
-	} else {
-		isConfig = qfalse;
-	}
-
-	search = (searchpath_t*)searchPath;
-
-	if(search == NULL)
-	{
-		// look for it in the filesystem or pack files
-		len = FS_FOpenFileRead(qpath, &h, qfalse);
-        }
-	else
-	{
-		// look for it in a specific search path only
-		len = FS_FOpenFileReadDir(qpath, search, &h, qfalse, unpure);
-	}
-
-	if ( h == 0 ) {
-		if ( buffer ) {
-			*buffer = NULL;
-		}
-		// if we are journalling and it is a config file, write a zero to the journal file
-		if ( isConfig && com_journal && com_journal->integer == 1 ) {
-			Com_DPrintf( "Writing zero for %s to journal file.\n", qpath );
-			len = 0;
-			FS_Write( &len, sizeof( len ), com_journalDataFile );
-			FS_Flush( com_journalDataFile );
-		}
-		return -1;
-	}
-	
-	if ( !buffer ) {
-		if ( isConfig && com_journal && com_journal->integer == 1 ) {
-			Com_DPrintf( "Writing len for %s to journal file.\n", qpath );
-			FS_Write( &len, sizeof( len ), com_journalDataFile );
-			FS_Flush( com_journalDataFile );
-		}
-		FS_FCloseFile( h);
-		return len;
-	}
-
-	fs_loadCount++;
-	fs_loadStack++;
-
-	buf = (byte*)Hunk_AllocateTempMemory(len+1);
-	*buffer = buf;
-
-	FS_Read (buf, len, h);
-
-	// guarantee that it will have a trailing 0 for string operations
-	buf[len] = 0;
-	FS_FCloseFile( h );
-
-	// if we are journalling and it is a config file, write it to the journal file
-	if ( isConfig && com_journal && com_journal->integer == 1 ) {
-		Com_DPrintf( "Writing %s to journal file.\n", qpath );
-		FS_Write( &len, sizeof( len ), com_journalDataFile );
-		FS_Write( buf, len, com_journalDataFile );
-		FS_Flush( com_journalDataFile );
-	}
-	return len;
-}
-
-/*
-============
-FS_ReadFile
-
-Filename are relative to the quake search path
-a null buffer will just return the file length without loading
-============
-*/
-long FS_ReadFile(const char *qpath, void **buffer)
-{
-	return FS_ReadFileDir(qpath, NULL, qfalse, buffer);
-}
-
-/*
-=============
-FS_FreeFile
-=============
-*/
-void FS_FreeFile( void *buffer ) {
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-	if ( !buffer ) {
-		Com_Error( ERR_FATAL, "FS_FreeFile( NULL )" );
-	}
-	fs_loadStack--;
-
-	Hunk_FreeTempMemory( buffer );
-
-	// if all of our temp files are free, clear all of our space
-	if ( fs_loadStack == 0 ) {
-		Hunk_ClearTempMemory();
-	}
-}
-
-/*
-============
-FS_WriteFile
-
-Filename are relative to the quake search path
-============
-*/
-void FS_WriteFile( const char *qpath, const void *buffer, int size ) {
-	fileHandle_t f;
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	if ( !qpath || !buffer ) {
-		Com_Error( ERR_FATAL, "FS_WriteFile: NULL parameter" );
-	}
-
-	f = FS_FOpenFileWrite( qpath );
-	if ( !f ) {
-		Com_Printf( "Failed to open %s\n", qpath );
-		return;
-	}
-
-	FS_Write( buffer, size, f );
-
-	FS_FCloseFile( f );
-}
-
-
-
-/*
-==========================================================================
-
-ZIP FILE LOADING
-
-==========================================================================
-*/
-
-/*
-=================
-FS_LoadZipFile
-
-Creates a new pak_t in the search chain for the contents
-of a zip file.
-=================
-*/
-static pack_t *FS_LoadZipFile(const char *zipfile, const char *basename)
-{
-	fileInPack_t	*buildBuffer;
-	pack_t			*pack;
-	unzFile			uf;
-	int				err;
-	unz_global_info gi;
-	char			filename_inzip[MAX_ZPATH];
-	unz_file_info	file_info;
-	int				i, len;
-	long			hash;
-	int				fs_numHeaderLongs;
-	int				*fs_headerLongs;
-	char			*namePtr;
-
-	fs_numHeaderLongs = 0;
-
-	uf = unzOpen(zipfile);
-	err = unzGetGlobalInfo (uf,&gi);
-
-	if (err != UNZ_OK)
-		return NULL;
-
-	len = 0;
-	unzGoToFirstFile(uf);
-	for (i = 0; i < gi.number_entry; i++)
-	{
-		err = unzGetCurrentFileInfo(uf, &file_info, filename_inzip, sizeof(filename_inzip), NULL, 0, NULL, 0);
-		if (err != UNZ_OK) {
-			break;
-		}
-		len += strlen(filename_inzip) + 1;
-		unzGoToNextFile(uf);
-	}
-
-	buildBuffer = ( fileInPack_t*)Z_Malloc( (gi.number_entry * sizeof( fileInPack_t )) + len );
-	namePtr = ((char *) buildBuffer) + gi.number_entry * sizeof( fileInPack_t );
-	fs_headerLongs = (int*)Z_Malloc( ( gi.number_entry + 1 ) * sizeof(int) );
-	fs_headerLongs[ fs_numHeaderLongs++ ] = LittleLong( fs_checksumFeed );
-
-	// get the hash table size from the number of files in the zip
-	// because lots of custom pk3 files have less than 32 or 64 files
-	for (i = 1; i <= MAX_FILEHASH_SIZE; i <<= 1) {
-		if (i > gi.number_entry) {
-			break;
-		}
-	}
-
-	pack = (pack_t*)Z_Malloc( sizeof( pack_t ) + i * sizeof(fileInPack_t *) );
-	pack->hashSize = i;
-	pack->hashTable = (fileInPack_t **) (((char *) pack) + sizeof( pack_t ));
-	for(i = 0; i < pack->hashSize; i++) {
-		pack->hashTable[i] = NULL;
-	}
-
-	Q_strncpyz( pack->pakFilename, zipfile, sizeof( pack->pakFilename ) );
-	Q_strncpyz( pack->pakBasename, basename, sizeof( pack->pakBasename ) );
-
-	// strip .pk3 if needed
-	if ( strlen( pack->pakBasename ) > 4 && !Q_stricmp( pack->pakBasename + strlen( pack->pakBasename ) - 4, ".pk3" ) ) {
-		pack->pakBasename[strlen( pack->pakBasename ) - 4] = 0;
-	}
-
-	pack->handle = uf;
-	pack->numfiles = gi.number_entry;
-	unzGoToFirstFile(uf);
-
-	for (i = 0; i < gi.number_entry; i++)
-	{
-		err = unzGetCurrentFileInfo(uf, &file_info, filename_inzip, sizeof(filename_inzip), NULL, 0, NULL, 0);
-		if (err != UNZ_OK) {
-			break;
-		}
-		if (file_info.uncompressed_size > 0) {
-			fs_headerLongs[fs_numHeaderLongs++] = LittleLong(file_info.crc);
-		}
-		Q_strlwr( filename_inzip );
-		hash = FS_HashFileName(filename_inzip, pack->hashSize);
-		buildBuffer[i].name = namePtr;
-		strcpy( buildBuffer[i].name, filename_inzip );
-		namePtr += strlen(filename_inzip) + 1;
-		// store the file position in the zip
-		buildBuffer[i].pos = unzGetOffset(uf);
-		buildBuffer[i].len = file_info.uncompressed_size;
-		buildBuffer[i].next = pack->hashTable[hash];
-		pack->hashTable[hash] = &buildBuffer[i];
-		unzGoToNextFile(uf);
-	}
-
-	pack->checksum = Com_BlockChecksum( &fs_headerLongs[ 1 ], sizeof(*fs_headerLongs) * ( fs_numHeaderLongs - 1 ) );
-	pack->pure_checksum = Com_BlockChecksum( fs_headerLongs, sizeof(*fs_headerLongs) * fs_numHeaderLongs );
-	pack->checksum = LittleLong( pack->checksum );
-	pack->pure_checksum = LittleLong( pack->pure_checksum );
-
-	Z_Free(fs_headerLongs);
-
-	pack->buildBuffer = buildBuffer;
-	return pack;
-}
-
-/*
-=================
-FS_FreePak
-
-Frees a pak structure and releases all associated resources
-=================
-*/
-
-static void FS_FreePak(pack_t *thepak)
-{
-	unzClose(thepak->handle);
-	Z_Free(thepak->buildBuffer);
-	Z_Free(thepak);
-}
-
-/*
-=================
-FS_GetZipChecksum
-
-Compares whether the given pak file matches a referenced checksum
-=================
-*/
-qboolean FS_CompareZipChecksum(const char *zipfile)
-{
-	pack_t *thepak;
-	int index, checksum;
-	
-	thepak = FS_LoadZipFile(zipfile, "");
-	
-	if(!thepak)
-		return qfalse;
-	
-	checksum = thepak->checksum;
-	FS_FreePak(thepak);
-	
-	for(index = 0; index < fs_numServerReferencedPaks; index++)
-	{
-		if(checksum == fs_serverReferencedPaks[index])
-			return qtrue;
-	}
-	
-	return qfalse;
-}
-
-/*
-=================================================================================
-
-DIRECTORY SCANNING FUNCTIONS
-
-=================================================================================
-*/
-
-#define	MAX_FOUND_FILES	0x1000
-
-static int FS_ReturnPath( const char *zname, char *zpath, int *depth ) {
-	int len, at, newdep;
-
-	newdep = 0;
-	zpath[0] = 0;
-	len = 0;
-	at = 0;
-
-	while(zname[at] != 0)
-	{
-		if (zname[at]=='/' || zname[at]=='\\') {
-			len = at;
-			newdep++;
-		}
-		at++;
-	}
-	strcpy(zpath, zname);
-	zpath[len] = 0;
-	*depth = newdep;
-
-	return len;
-}
-
-/*
-==================
-FS_AddFileToList
-==================
-*/
-static int FS_AddFileToList( char *name, char *list[MAX_FOUND_FILES], int nfiles ) {
-	int		i;
-
-	if ( nfiles == MAX_FOUND_FILES - 1 ) {
-		return nfiles;
-	}
-	for ( i = 0 ; i < nfiles ; i++ ) {
-		if ( !Q_stricmp( name, list[i] ) ) {
-			return nfiles;		// allready in list
-		}
-	}
-	list[nfiles] = CopyString( name );
-	nfiles++;
-
-	return nfiles;
-}
-
-/*
-===============
-FS_ListFilteredFiles
-
-Returns a uniqued list of files that match the given criteria
-from all search paths
-===============
-*/
-char **FS_ListFilteredFiles( const char *path, const char *extension, const char *filter, int *numfiles, qboolean allowNonPureFilesOnDisk ) {
-	int				nfiles;
-	char			**listCopy;
-	char			*list[MAX_FOUND_FILES];
-	searchpath_t	*search;
-	int				i;
-	int				pathLength;
-	int				extensionLength;
-	int				length, pathDepth, temp;
-	pack_t			*pak;
-	fileInPack_t	*buildBuffer;
-	char			zpath[MAX_ZPATH];
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	if ( !path ) {
-		*numfiles = 0;
-		return NULL;
-	}
-	if ( !extension ) {
-		extension = "";
-	}
-
-	pathLength = strlen( path );
-	if ( path[pathLength-1] == '\\' || path[pathLength-1] == '/' ) {
-		pathLength--;
-	}
-	extensionLength = strlen( extension );
-	nfiles = 0;
-	FS_ReturnPath(path, zpath, &pathDepth);
-
-	//
-	// search through the path, one element at a time, adding to list
-	//
-	for (search = fs_searchpaths ; search ; search = search->next) {
-		// is the element a pak file?
-		if (search->pack) {
-
-			//ZOID:  If we are pure, don't search for files on paks that
-			// aren't on the pure list
-			if ( !FS_PakIsPure(search->pack) ) {
-				continue;
-			}
-
-			// look through all the pak file elements
-			pak = search->pack;
-			buildBuffer = pak->buildBuffer;
-			for (i = 0; i < pak->numfiles; i++) {
-				char	*name;
-				int		zpathLen, depth;
-
-				// check for directory match
-				name = buildBuffer[i].name;
-				//
-				if (filter) {
-					// case insensitive
-					if (!Com_FilterPath( filter, name, qfalse ))
-						continue;
-					// unique the match
-					nfiles = FS_AddFileToList( name, list, nfiles );
-				}
-				else {
-
-					zpathLen = FS_ReturnPath(name, zpath, &depth);
-
-					if ( (depth-pathDepth)>2 || pathLength > zpathLen || Q_stricmpn( name, path, pathLength ) ) {
-						continue;
-					}
-
-					// check for extension match
-					length = strlen( name );
-					if ( length < extensionLength ) {
-						continue;
-					}
-
-					if ( Q_stricmp( name + length - extensionLength, extension ) ) {
-						continue;
-					}
-					// unique the match
-
-					temp = pathLength;
-					if (pathLength) {
-						temp++;		// include the '/'
-					}
-					nfiles = FS_AddFileToList( name + temp, list, nfiles );
-				}
-			}
-		} else if (search->dir) { // scan for files in the filesystem
-			char	*netpath;
-			int		numSysFiles;
-			char	**sysFiles;
-			char	*name;
-
-			// don't scan directories for files if we are pure or restricted
-			if ( fs_numServerPaks && !allowNonPureFilesOnDisk ) {
-		        continue;
-		    } else {
-				netpath = FS_BuildOSPath( search->dir->path, search->dir->gamedir, path );
-				sysFiles = Sys_ListFiles( netpath, extension, filter, &numSysFiles, qfalse );
-				for ( i = 0 ; i < numSysFiles ; i++ ) {
-					// unique the match
-					name = sysFiles[i];
-					nfiles = FS_AddFileToList( name, list, nfiles );
-				}
-				Sys_FreeFileList( sysFiles );
-			}
-		}		
-	}
-
-	// return a copy of the list
-	*numfiles = nfiles;
-
-	if ( !nfiles ) {
-		return NULL;
-	}
-
-	listCopy = (char**)Z_Malloc( ( nfiles + 1 ) * sizeof( *listCopy ) );
-	for ( i = 0 ; i < nfiles ; i++ ) {
-		listCopy[i] = list[i];
-	}
-	listCopy[i] = NULL;
-
-	return listCopy;
-}
-
-/*
-=================
-FS_ListFiles
-=================
-*/
-char **FS_ListFiles( const char *path, const char *extension, int *numfiles ) {
-	return FS_ListFilteredFiles( path, extension, NULL, numfiles, qfalse );
-}
-
-/*
-=================
-FS_FreeFileList
-=================
-*/
-void FS_FreeFileList( char **list ) {
-	int		i;
-
-	if ( !fs_searchpaths ) {
-		Com_Error( ERR_FATAL, "Filesystem call made without initialization" );
-	}
-
-	if ( !list ) {
-		return;
-	}
-
-	for ( i = 0 ; list[i] ; i++ ) {
-		Z_Free( list[i] );
-	}
-
-	Z_Free( list );
-}
-
-
-/*
-================
-FS_GetFileList
-================
-*/
-int	FS_GetFileList(  const char *path, const char *extension, char *listbuf, int bufsize ) {
-	int		nFiles, i, nTotal, nLen;
-	char **pFiles = NULL;
-
-	*listbuf = 0;
-	nFiles = 0;
-	nTotal = 0;
-
-	if (Q_stricmp(path, "$modlist") == 0) {
-		return FS_GetModList(listbuf, bufsize);
-	}
-
-	pFiles = FS_ListFiles(path, extension, &nFiles);
-
-	for (i =0; i < nFiles; i++) {
-		nLen = strlen(pFiles[i]) + 1;
-		if (nTotal + nLen + 1 < bufsize) {
-			strcpy(listbuf, pFiles[i]);
-			listbuf += nLen;
-			nTotal += nLen;
-		}
-		else {
-			nFiles = i;
-			break;
-		}
-	}
-
-	FS_FreeFileList(pFiles);
-
-	return nFiles;
-}
-
-/*
-=======================
-Sys_ConcatenateFileLists
-
-mkv: Naive implementation. Concatenates three lists into a
-     new list, and frees the old lists from the heap.
-bk001129 - from cvs1.17 (mkv)
-
-FIXME TTimo those two should move to common.c next to Sys_ListFiles
-=======================
- */
-static unsigned int Sys_CountFileList(char **list)
-{
-	int i = 0;
-
-	if (list)
-	{
-		while (*list)
-		{
-			list++;
-			i++;
-		}
-	}
-	return i;
-}
-
-static char** Sys_ConcatenateFileLists( char **list0, char **list1 )
-{
-	int totalLength = 0;
-	char** cat = NULL, **dst, **src;
-
-	totalLength += Sys_CountFileList(list0);
-	totalLength += Sys_CountFileList(list1);
-
-	/* Create new list. */
-	dst = cat = (char**)Z_Malloc( ( totalLength + 1 ) * sizeof( char* ) );
-
-	/* Copy over lists. */
-	if (list0)
-	{
-		for (src = list0; *src; src++, dst++)
-			*dst = *src;
-	}
-	if (list1)
-	{
-		for (src = list1; *src; src++, dst++)
-			*dst = *src;
-	}
-
-	// Terminate the list
-	*dst = NULL;
-
-	// Free our old lists.
-	// NOTE: not freeing their content, it's been merged in dst and still being used
-	if (list0) Z_Free( list0 );
-	if (list1) Z_Free( list1 );
-
-	return cat;
-}
-
-/*
-================
-FS_GetModList
-
-Returns a list of mod directory names
-A mod directory is a peer to baseq3 with a pk3 in it
-The directories are searched in base path, cd path and home path
-================
-*/
-int	FS_GetModList( char *listbuf, int bufsize ) {
-	int		nMods, i, j, nTotal, nLen, nPaks, nPotential, nDescLen;
-	char **pFiles = NULL;
-	char **pPaks = NULL;
-	char *name, *path;
-	char descPath[MAX_OSPATH];
-	fileHandle_t descHandle;
-
-	int dummy;
-	char **pFiles0 = NULL;
-	char **pFiles1 = NULL;
-	qboolean bDrop = qfalse;
-
-	*listbuf = 0;
-	nMods = nTotal = 0;
-
-	pFiles0 = Sys_ListFiles( fs_homepath->string, NULL, NULL, &dummy, qtrue );
-	pFiles1 = Sys_ListFiles( fs_basepath->string, NULL, NULL, &dummy, qtrue );
-	// we searched for mods in the three paths
-	// it is likely that we have duplicate names now, which we will cleanup below
-	pFiles = Sys_ConcatenateFileLists( pFiles0, pFiles1 );
-	nPotential = Sys_CountFileList(pFiles);
-
-	for ( i = 0 ; i < nPotential ; i++ ) {
-		name = pFiles[i];
-		// NOTE: cleaner would involve more changes
-		// ignore duplicate mod directories
-		if (i!=0) {
-			bDrop = qfalse;
-			for(j=0; j<i; j++)
-			{
-				if (Q_stricmp(pFiles[j],name)==0) {
-					// this one can be dropped
-					bDrop = qtrue;
-					break;
-				}
-			}
-		}
-		if (bDrop) {
-			continue;
-		}
-		// we drop "baseq3" "." and ".."
-		if (Q_stricmp(name, com_basegame->string) && Q_stricmpn(name, ".", 1)) {
-			// now we need to find some .pk3 files to validate the mod
-			// NOTE TTimo: (actually I'm not sure why .. what if it's a mod under developement with no .pk3?)
-			// we didn't keep the information when we merged the directory names, as to what OS Path it was found under
-			//   so it could be in base path, cd path or home path
-			//   we will try each three of them here (yes, it's a bit messy)
-			path = FS_BuildOSPath( fs_basepath->string, name, "" );
-			nPaks = 0;
-			pPaks = Sys_ListFiles(path, ".pk3", NULL, &nPaks, qfalse); 
-			Sys_FreeFileList( pPaks ); // we only use Sys_ListFiles to check wether .pk3 files are present
-
-			/* try on home path */
-			if ( nPaks <= 0 )
-			{
-				path = FS_BuildOSPath( fs_homepath->string, name, "" );
-				nPaks = 0;
-				pPaks = Sys_ListFiles( path, ".pk3", NULL, &nPaks, qfalse );
-				Sys_FreeFileList( pPaks );
-			}
-
-			if (nPaks > 0) {
-				nLen = strlen(name) + 1;
-				// nLen is the length of the mod path
-				// we need to see if there is a description available
-				descPath[0] = '\0';
-				strcpy(descPath, name);
-				strcat(descPath, "/description.txt");
-				nDescLen = FS_SV_FOpenFileRead( descPath, &descHandle );
-				if ( nDescLen > 0 && descHandle) {
-					FILE *file;
-					file = FS_FileForHandle(descHandle);
-					Com_Memset( descPath, 0, sizeof( descPath ) );
-					nDescLen = fread(descPath, 1, 48, file);
-					if (nDescLen >= 0) {
-						descPath[nDescLen] = '\0';
-					}
-					FS_FCloseFile(descHandle);
-				} else {
-					strcpy(descPath, name);
-				}
-				nDescLen = strlen(descPath) + 1;
-
-				if (nTotal + nLen + 1 + nDescLen + 1 < bufsize) {
-					strcpy(listbuf, name);
-					listbuf += nLen;
-					strcpy(listbuf, descPath);
-					listbuf += nDescLen;
-					nTotal += nLen + nDescLen;
-					nMods++;
-				}
-				else {
-					break;
-				}
-			}
-		}
-	}
-	Sys_FreeFileList( pFiles );
-
-	return nMods;
-}
-
-
-
-
-//============================================================================
-
-/*
-================
-FS_Dir_f
-================
-*/
-void FS_Dir_f( void ) {
-	const char	*path;
-	const char	*extension;
-	char	**dirnames;
-	int		ndirs;
-	int		i;
-
-	if ( Cmd_Argc() < 2 || Cmd_Argc() > 3 ) {
-		Com_Printf( "usage: dir <directory> [extension]\n" );
-		return;
-	}
-
-	if ( Cmd_Argc() == 2 ) {
-		path = Cmd_Argv( 1 );
-		extension = "";
-	} else {
-		path = Cmd_Argv( 1 );
-		extension = Cmd_Argv( 2 );
-	}
-
-	Com_Printf( "Directory of %s %s\n", path, extension );
-	Com_Printf( "---------------\n" );
-
-	dirnames = FS_ListFiles( path, extension, &ndirs );
-
-	for ( i = 0; i < ndirs; i++ ) {
-		Com_Printf( "%s\n", dirnames[i] );
-	}
-	FS_FreeFileList( dirnames );
-}
-
-/*
-===========
-FS_ConvertPath
-===========
-*/
-void FS_ConvertPath( char *s ) {
-	while (*s) {
-		if ( *s == '\\' || *s == ':' ) {
-			*s = '/';
-		}
-		s++;
-	}
-}
-
-/*
-===========
-FS_PathCmp
-
-Ignore case and seprator char distinctions
-===========
-*/
-int FS_PathCmp( const char *s1, const char *s2 ) {
-	int		c1, c2;
-
-	do {
-		c1 = *s1++;
-		c2 = *s2++;
-
-		if (c1 >= 'a' && c1 <= 'z') {
-			c1 -= ('a' - 'A');
-		}
-		if (c2 >= 'a' && c2 <= 'z') {
-			c2 -= ('a' - 'A');
-		}
-
-		if ( c1 == '\\' || c1 == ':' ) {
-			c1 = '/';
-		}
-		if ( c2 == '\\' || c2 == ':' ) {
-			c2 = '/';
-		}
-		
-		if (c1 < c2) {
-			return -1;		// strings not equal
-		}
-		if (c1 > c2) {
-			return 1;
-		}
-	} while (c1);
-	
-	return 0;		// strings are equal
-}
-
-/*
-================
-FS_SortFileList
-================
-*/
-void FS_SortFileList(char **filelist, int numfiles) {
-	int i, j, k, numsortedfiles;
-	char **sortedlist;
-
-	sortedlist = (char**)Z_Malloc( ( numfiles + 1 ) * sizeof( *sortedlist ) );
-	sortedlist[0] = NULL;
-	numsortedfiles = 0;
-	for (i = 0; i < numfiles; i++) {
-		for (j = 0; j < numsortedfiles; j++) {
-			if (FS_PathCmp(filelist[i], sortedlist[j]) < 0) {
-				break;
-			}
-		}
-		for (k = numsortedfiles; k > j; k--) {
-			sortedlist[k] = sortedlist[k-1];
-		}
-		sortedlist[j] = filelist[i];
-		numsortedfiles++;
-	}
-	Com_Memcpy(filelist, sortedlist, numfiles * sizeof( *filelist ) );
-	Z_Free(sortedlist);
-}
-
-/*
-================
-FS_NewDir_f
-================
-*/
-void FS_NewDir_f( void ) {
-	const char	*filter;
-	char	**dirnames;
-	int		ndirs;
-	int		i;
-
-	if ( Cmd_Argc() < 2 ) {
-		Com_Printf( "usage: fdir <filter>\n" );
-		Com_Printf( "example: fdir *q3dm*.bsp\n");
-		return;
-	}
-
-	filter = Cmd_Argv( 1 );
-
-	Com_Printf( "---------------\n" );
-
-	dirnames = FS_ListFilteredFiles( "", "", filter, &ndirs, qfalse );
-
-	FS_SortFileList(dirnames, ndirs);
-
-	for ( i = 0; i < ndirs; i++ ) {
-		FS_ConvertPath(dirnames[i]);
-		Com_Printf( "%s\n", dirnames[i] );
-	}
-	Com_Printf( "%d files listed\n", ndirs );
-	FS_FreeFileList( dirnames );
-}
-
-/*
-============
-FS_Path_f
-
-============
-*/
-void FS_Path_f( void ) {
-	searchpath_t	*s;
-	int				i;
-
-	Com_Printf ("Current search path:\n");
-	for (s = fs_searchpaths; s; s = s->next) {
-		if (s->pack) {
-			Com_Printf ("%s (%i files)\n", s->pack->pakFilename, s->pack->numfiles);
-			if ( fs_numServerPaks ) {
-				if ( !FS_PakIsPure(s->pack) ) {
-					Com_Printf( "    not on the pure list\n" );
-				} else {
-					Com_Printf( "    on the pure list\n" );
-				}
-			}
-		} else {
-			Com_Printf ("%s%c%s\n", s->dir->path, PATH_SEP, s->dir->gamedir );
-		}
-	}
-
-
-	Com_Printf( "\n" );
-	for ( i = 1 ; i < MAX_FILE_HANDLES ; i++ ) {
-		if ( fsh[i].handleFiles.file.o ) {
-			Com_Printf( "handle %i: %s\n", i, fsh[i].name );
-		}
-	}
-}
-
-/*
-============
-FS_TouchFile_f
-============
-*/
-void FS_TouchFile_f( void ) {
-	fileHandle_t	f;
-
-	if ( Cmd_Argc() != 2 ) {
-		Com_Printf( "Usage: touchFile <file>\n" );
-		return;
-	}
-
-	FS_FOpenFileRead( Cmd_Argv( 1 ), &f, qfalse );
-	if ( f ) {
-		FS_FCloseFile( f );
-	}
-}
-
-/*
-============
-FS_Which
-============
-*/
-
-qboolean FS_Which(const char *filename, void *searchPath)
-{
-	searchpath_t *search = (searchpath_t *)searchPath;
-
-	if(FS_FOpenFileReadDir(filename, search, NULL, qfalse, qfalse) > 0)
-	{
-		if(search->pack)
-		{
-			Com_Printf("File \"%s\" found in \"%s\"\n", filename, search->pack->pakFilename);
-			return qtrue;
-		}
-		else if(search->dir)
-		{
-			Com_Printf( "File \"%s\" found at \"%s\"\n", filename, search->dir->fullpath);
-			return qtrue;
-		}
-	}
-
-	return qfalse;
-}
-
-/*
-============
-FS_Which_f
-============
-*/
-void FS_Which_f( void ) {
-	searchpath_t	*search;
-	const char		*filename;
-
-	filename = Cmd_Argv(1);
-
-	if ( !filename[0] ) {
-		Com_Printf( "Usage: which <file>\n" );
-		return;
-	}
-
-	// qpaths are not supposed to have a leading slash
-	if ( filename[0] == '/' || filename[0] == '\\' ) {
-		filename++;
-	}
-
-	// just wants to see if file is there
-	for(search = fs_searchpaths; search; search = search->next)
-	{
-		if(FS_Which(filename, search))
-			return;
-	}
-
-	Com_Printf("File not found: \"%s\"\n", filename);
-	return;
-}
-
-
-//===========================================================================
-
-
-static int QDECL paksort( const void *a, const void *b ) {
-	char	*aa, *bb;
-
-	aa = *(char **)a;
-	bb = *(char **)b;
-
-	return FS_PathCmp( aa, bb );
-}
-
-/*
-================
-FS_AddGameDirectory
-
-Sets fs_gamedir, adds the directory to the head of the path,
-then loads the zip headers
-================
-*/
-void FS_AddGameDirectory( const char *path, const char *dir ) {
-	searchpath_t	*sp;
-	int				i;
-	searchpath_t	*search;
-	pack_t			*pak;
-	char			curpath[MAX_OSPATH + 1], *pakfile;
-	int				numfiles;
-	char			**pakfiles;
-
-	// Unique
-	for ( sp = fs_searchpaths ; sp ; sp = sp->next ) {
-		if ( sp->dir && !Q_stricmp(sp->dir->path, path) && !Q_stricmp(sp->dir->gamedir, dir)) {
-			return;			// we've already got this one
-		}
-	}
-	
-	Q_strncpyz( fs_gamedir, dir, sizeof( fs_gamedir ) );
-
-	// find all pak files in this directory
-	Q_strncpyz(curpath, FS_BuildOSPath(path, dir, ""), sizeof(curpath));
-	curpath[strlen(curpath) - 1] = '\0';	// strip the trailing slash
-
-#if 0
-	pakfiles = Sys_ListFiles(curpath, ".pk3", NULL, &numfiles, qfalse);
-#else
-	// hack to load .pk4 files as well
-	// TODO: it could be done better way
-	pakfiles = Sys_ListFiles(curpath, ".pk*", NULL, &numfiles, qfalse);
-#endif
-	qsort( pakfiles, numfiles, sizeof(char*), paksort );
-
-	for ( i = 0 ; i < numfiles ; i++ ) {
-		pakfile = FS_BuildOSPath( path, dir, pakfiles[i] );
-		if ( ( pak = FS_LoadZipFile( pakfile, pakfiles[i] ) ) == 0 )
-			continue;
-
-		Q_strncpyz(pak->pakPathname, curpath, sizeof(pak->pakPathname));
-		// store the game name for downloading
-		Q_strncpyz(pak->pakGamename, dir, sizeof(pak->pakGamename));
-		
-		fs_packFiles += pak->numfiles;
-
-		search = (searchpath_t*)Z_Malloc (sizeof(searchpath_t));
-		search->pack = pak;
-		search->next = fs_searchpaths;
-		fs_searchpaths = search;
-	}
-
-	// done
-	Sys_FreeFileList( pakfiles );
-
-	//
-	// add the directory to the search path
-	//
-	search = (searchpath_t*)Z_Malloc (sizeof(searchpath_t));
-	search->dir = (directory_t*) Z_Malloc( sizeof( *search->dir ) );
-
-	Q_strncpyz(search->dir->path, path, sizeof(search->dir->path));
-	Q_strncpyz(search->dir->fullpath, curpath, sizeof(search->dir->fullpath));
-	Q_strncpyz(search->dir->gamedir, dir, sizeof(search->dir->gamedir));
-
-	search->next = fs_searchpaths;
-	fs_searchpaths = search;
-}
-
-/*
-================
-FS_idPak
-================
-*/
-qboolean FS_idPak(char *pak, char *base, int numPaks)
-{
-	int i;
-
-	for (i = 0; i < NUM_ID_PAKS; i++) {
-		if ( !FS_FilenameCompare(pak, va("%s/pak%d", base, i)) ) {
-			break;
-		}
-	}
-	if (i < numPaks) {
-		return qtrue;
-	}
-	return qfalse;
-}
-
-/*
-================
-FS_CheckDirTraversal
-
-Check whether the string contains stuff like "../" to prevent directory traversal bugs
-and return qtrue if it does.
-================
-*/
-
-qboolean FS_CheckDirTraversal(const char *checkdir)
-{
-	if(strstr(checkdir, "../") || strstr(checkdir, "..\\"))
-		return qtrue;
-	
-	return qfalse;
-}
-
-/*
-================
-FS_ComparePaks
-
-----------------
-dlstring == qtrue
-
-Returns a list of pak files that we should download from the server. They all get stored
-in the current gamedir and an FS_Restart will be fired up after we download them all.
-
-The string is the format:
-
-@remotename@localname [repeat]
-
-static int		fs_numServerReferencedPaks;
-static int		fs_serverReferencedPaks[MAX_SEARCH_PATHS];
-static char		*fs_serverReferencedPakNames[MAX_SEARCH_PATHS];
-
-----------------
-dlstring == qfalse
-
-we are not interested in a download string format, we want something human-readable
-(this is used for diagnostics while connecting to a pure server)
-
-================
-*/
-qboolean FS_ComparePaks( char *neededpaks, int len, qboolean dlstring ) {
-	searchpath_t	*sp;
-	qboolean havepak;
-	char *origpos = neededpaks;
-	int i;
-
-	if (!fs_numServerReferencedPaks)
-		return qfalse; // Server didn't send any pack information along
-
-	*neededpaks = 0;
-
-	for ( i = 0 ; i < fs_numServerReferencedPaks ; i++ )
-	{
-		// Ok, see if we have this pak file
-		havepak = qfalse;
-
-		// never autodownload any of the id paks
-		if(FS_idPak(fs_serverReferencedPakNames[i], BASEGAME, NUM_ID_PAKS)
-#ifndef STANDALONE
-		   || FS_idPak(fs_serverReferencedPakNames[i], BASETA, NUM_TA_PAKS)
-#endif
-		  )
-		{
-			continue;
-		}
-
-		// Make sure the server cannot make us write to non-quake3 directories.
-		if(FS_CheckDirTraversal(fs_serverReferencedPakNames[i]))
-		{
-			Com_Printf("WARNING: Invalid download name %s\n", fs_serverReferencedPakNames[i]);
-			continue;
-		}
-
-		for ( sp = fs_searchpaths ; sp ; sp = sp->next ) {
-			if ( sp->pack && sp->pack->checksum == fs_serverReferencedPaks[i] ) {
-				havepak = qtrue; // This is it!
-				break;
-			}
-		}
-
-		if ( !havepak && fs_serverReferencedPakNames[i] && *fs_serverReferencedPakNames[i] ) { 
-			// Don't got it
-
-			if (dlstring)
-			{
-				// We need this to make sure we won't hit the end of the buffer or the server could
-				// overwrite non-pk3 files on clients by writing so much crap into neededpaks that
-				// Q_strcat cuts off the .pk3 extension.
-
-				origpos += strlen(origpos);
-
-				// Remote name
-				Q_strcat( neededpaks, len, "@");
-				Q_strcat( neededpaks, len, fs_serverReferencedPakNames[i] );
-				Q_strcat( neededpaks, len, ".pk3" );
-
-				// Local name
-				Q_strcat( neededpaks, len, "@");
-				// Do we have one with the same name?
-				if ( FS_SV_FileExists( va( "%s.pk3", fs_serverReferencedPakNames[i] ) ) )
-				{
-					char st[MAX_ZPATH];
-					// We already have one called this, we need to download it to another name
-					// Make something up with the checksum in it
-					Com_sprintf( st, sizeof( st ), "%s.%08x.pk3", fs_serverReferencedPakNames[i], fs_serverReferencedPaks[i] );
-					Q_strcat( neededpaks, len, st );
-				}
-				else
-				{
-					Q_strcat( neededpaks, len, fs_serverReferencedPakNames[i] );
-					Q_strcat( neededpaks, len, ".pk3" );
-				}
-
-				// Find out whether it might have overflowed the buffer and don't add this file to the
-				// list if that is the case.
-				if(strlen(origpos) + (origpos - neededpaks) >= len - 1)
-				{
-					*origpos = '\0';
-					break;
-				}
-			}
-			else
-			{
-				Q_strcat( neededpaks, len, fs_serverReferencedPakNames[i] );
-				Q_strcat( neededpaks, len, ".pk3" );
-				// Do we have one with the same name?
-				if ( FS_SV_FileExists( va( "%s.pk3", fs_serverReferencedPakNames[i] ) ) )
-				{
-					Q_strcat( neededpaks, len, " (local file exists with wrong checksum)");
-				}
-				Q_strcat( neededpaks, len, "\n");
-			}
-		}
-	}
-
-	if ( *neededpaks ) {
-		return qtrue;
-	}
-
-	return qfalse; // We have them all
-}
-
-/*
-================
-FS_Shutdown
-
-Frees all resources.
-================
-*/
-void FS_Shutdown( qboolean closemfp ) {
-	searchpath_t	*p, *next;
-	int	i;
-
-	for(i = 0; i < MAX_FILE_HANDLES; i++) {
-		if (fsh[i].fileSize) {
-			FS_FCloseFile(i);
-		}
-	}
-
-	// free everything
-	for(p = fs_searchpaths; p; p = next)
-	{
-		next = p->next;
-
-		if(p->pack)
-			FS_FreePak(p->pack);
-		if (p->dir)
-			Z_Free(p->dir);
-
-		Z_Free(p);
-	}
-
-	// any FS_ calls will now be an error until reinitialized
-	fs_searchpaths = NULL;
-
-	Cmd_RemoveCommand( "path" );
-	Cmd_RemoveCommand( "dir" );
-	Cmd_RemoveCommand( "fdir" );
-	Cmd_RemoveCommand( "touchFile" );
-	Cmd_RemoveCommand( "which" );
-
-#ifdef FS_MISSING
-	if (closemfp) {
-		fclose(missingFiles);
-	}
-#endif
-}
-
-#ifndef STANDALONE
-void Com_AppendCDKey( const char *filename );
-void Com_ReadCDKey( const char *filename );
-#endif
-
-/*
-================
-FS_ReorderPurePaks
-NOTE TTimo: the reordering that happens here is not reflected in the cvars (\cvarlist *pak*)
-  this can lead to misleading situations, see https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=540
-================
-*/
-static void FS_ReorderPurePaks( void )
-{
-	searchpath_t *s;
-	int i;
-	searchpath_t **p_insert_index, // for linked list reordering
-		**p_previous; // when doing the scan
-
-	fs_reordered = qfalse;
-
-	// only relevant when connected to pure server
-	if ( !fs_numServerPaks )
-		return;
-
-	p_insert_index = &fs_searchpaths; // we insert in order at the beginning of the list
-	for ( i = 0 ; i < fs_numServerPaks ; i++ ) {
-		p_previous = p_insert_index; // track the pointer-to-current-item
-		for (s = *p_insert_index; s; s = s->next) {
-			// the part of the list before p_insert_index has been sorted already
-			if (s->pack && fs_serverPaks[i] == s->pack->checksum) {
-				fs_reordered = qtrue;
-				// move this element to the insert list
-				*p_previous = s->next;
-				s->next = *p_insert_index;
-				*p_insert_index = s;
-				// increment insert list
-				p_insert_index = &s->next;
-				break; // iterate to next server pack
-			}
-			p_previous = &s->next;
-		}
-	}
-}
-
-/*
-================
-FS_Startup
-================
-*/
-static void FS_Startup( const char *gameName )
-{
-	const char *homePath;
-
-	Com_Printf( "----- FS_Startup -----\n" );
-
-	fs_packFiles = 0;
-
-	fs_debug = Cvar_Get( "fs_debug", "0", 0 );
-	fs_basepath = Cvar_Get ("fs_basepath", Sys_DefaultInstallPath(), CVAR_INIT|CVAR_PROTECTED );
-	fs_basegame = Cvar_Get ("fs_basegame", "", CVAR_INIT );
-	homePath = Sys_DefaultHomePath();
-	if (!homePath || !homePath[0]) {
-		homePath = fs_basepath->string;
-	}
-	fs_homepath = Cvar_Get ("fs_homepath", homePath, CVAR_INIT|CVAR_PROTECTED );
-	fs_gamedirvar = Cvar_Get ("fs_game", "", CVAR_INIT|CVAR_SYSTEMINFO );
-
-	// temporary hack
-	FS_AddGameDirectory("E:/MoHAA","main");
-	//FS_AddGameDirectory("E:/Call of Duty","main");
-
-	// add search path elements in reverse priority order
-	if (fs_basepath->string[0]) {
-		FS_AddGameDirectory( fs_basepath->string, gameName );
-	}
-	// fs_homepath is somewhat particular to *nix systems, only add if relevant
-	
-	#ifdef MACOS_X
-	fs_apppath = Cvar_Get ("fs_apppath", Sys_DefaultAppPath(), CVAR_INIT|CVAR_PROTECTED );
-	// Make MacOSX also include the base path included with the .app bundle
-	if (fs_apppath->string[0])
-		FS_AddGameDirectory(fs_apppath->string, gameName);
-	#endif
-	
-	// NOTE: same filtering below for mods and basegame
-	//if (fs_homepath->string[0] && Q_stricmp(fs_homepath->string,fs_basepath->string)) {
-	//	FS_CreatePath ( fs_homepath->string );
-	//	FS_AddGameDirectory ( fs_homepath->string, gameName );
-	//}
-
-	// check for additional base game so mods can be based upon other mods
-	if ( fs_basegame->string[0] && Q_stricmp( fs_basegame->string, gameName ) ) {
-		if (fs_basepath->string[0]) {
-			FS_AddGameDirectory(fs_basepath->string, fs_basegame->string);
-		}
-		//if (fs_homepath->string[0] && Q_stricmp(fs_homepath->string,fs_basepath->string)) {
-		//	FS_AddGameDirectory(fs_homepath->string, fs_basegame->string);
-		//}
-	}
-
-	// check for additional game folder for mods
-	if ( fs_gamedirvar->string[0] && Q_stricmp( fs_gamedirvar->string, gameName ) ) {
-		if (fs_basepath->string[0]) {
-			FS_AddGameDirectory(fs_basepath->string, fs_gamedirvar->string);
-		}
-		//if (fs_homepath->string[0] && Q_stricmp(fs_homepath->string,fs_basepath->string)) {
-		//	FS_AddGameDirectory(fs_homepath->string, fs_gamedirvar->string);
-		//}
-	}
-
-#ifndef STANDALONE
-	if(!com_standalone->integer)
-	{
-		cvar_s	*fs;
-
-		Com_ReadCDKey(BASEGAME);
-		fs = Cvar_Get ("fs_game", "", CVAR_INIT|CVAR_SYSTEMINFO );
-		if (fs && fs->string[0] != 0) {
-			Com_AppendCDKey( fs->string );
-		}
-	}
-#endif
-
-	// add our commands
-	Cmd_AddCommand ("path", FS_Path_f);
-	Cmd_AddCommand ("dir", FS_Dir_f );
-	Cmd_AddCommand ("fdir", FS_NewDir_f );
-	Cmd_AddCommand ("touchFile", FS_TouchFile_f );
-	Cmd_AddCommand ("which", FS_Which_f );
-
-	// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=506
-	// reorder the pure pk3 files according to server order
-	FS_ReorderPurePaks();
-
-	// print the current search paths
-	FS_Path_f();
-
-	fs_gamedirvar->modified = qfalse; // We just loaded, it's not modified
-
-	Com_Printf( "----------------------\n" );
-
-#ifdef FS_MISSING
-	if (missingFiles == NULL) {
-		missingFiles = fopen( "\\missing.txt", "ab" );
-	}
-#endif
-	Com_Printf( "%d files in pk3 files\n", fs_packFiles );
-}
-
-#ifndef STANDALONE
-/*
-===================
-FS_CheckPak0
-
-Check whether any of the original id pak files is present,
-and start up in standalone mode, if there are none and a
-different com_basegame was set.
-Note: If you're building a game that doesn't depend on the
-Q3 media pak0.pk3, you'll want to remove this by defining
-STANDALONE in q_shared.h
-===================
-*/
-static void FS_CheckPak0( void )
-{
-	searchpath_t	*path;
-	pack_t		*curpack;
-	qboolean founddemo = qfalse;
-	unsigned int foundPak = 0, foundTA = 0;
-
-	for( path = fs_searchpaths; path; path = path->next )
-	{
-		const char* pakBasename = path->pack->pakBasename;
-
-		if(!path->pack)
-			continue;
-		
-		curpack = path->pack;
-
-		if(!Q_stricmpn( curpack->pakGamename, "demoq3", MAX_OSPATH )
-		   && !Q_stricmpn( pakBasename, "pak0", MAX_OSPATH ))
-		{
-			if(curpack->checksum == DEMO_PAK0_CHECKSUM)
-				founddemo = qtrue;
-		}
-
-		else if(!Q_stricmpn( curpack->pakGamename, BASEGAME, MAX_OSPATH )
-			&& strlen(pakBasename) == 4 && !Q_stricmpn( pakBasename, "pak", 3 )
-			&& pakBasename[3] >= '0' && pakBasename[3] <= '0' + NUM_ID_PAKS - 1)
-		{
-			if( curpack->checksum != pak_checksums[pakBasename[3]-'0'] )
-			{
-				if(pakBasename[3] == '0')
-				{
-					Com_Printf("\n\n"
-						"**************************************************\n"
-						"WARNING: " BASEGAME "/pak0.pk3 is present but its checksum (%u)\n"
-						"is not correct. Please re-copy pak0.pk3 from your\n"
-						"legitimate Q3 CDROM.\n"
-						"**************************************************\n\n\n",
-						curpack->checksum );
-				}
-				else
-				{
-					Com_Printf("\n\n"
-						"**************************************************\n"
-						"WARNING: " BASEGAME "/pak%d.pk3 is present but its checksum (%u)\n"
-						"is not correct. Please re-install the point release\n"
-						"**************************************************\n\n\n",
-						pakBasename[3]-'0', curpack->checksum );
-				}
-			}
-
-			foundPak |= 1<<(pakBasename[3]-'0');
-		}
-		else if(!Q_stricmpn(curpack->pakGamename, BASETA, MAX_OSPATH)
-			&& strlen(pakBasename) == 4 && !Q_stricmpn(pakBasename, "pak", 3)
-			&& pakBasename[3] >= '0' && pakBasename[3] <= '0' + NUM_TA_PAKS - 1)
-			
-		{
-			if(curpack->checksum != missionpak_checksums[pakBasename[3]-'0'])
-			{
-				Com_Printf("\n\n"
-					"**************************************************\n"
-					"WARNING: " BASETA "/pak%d.pk3 is present but its checksum (%u)\n"
-					"is not correct. Please re-install Team Arena\n"
-					"**************************************************\n\n\n",
-					pakBasename[3]-'0', curpack->checksum );				
-			}
-			
-			foundTA |= 1 << (pakBasename[3]-'0');
-		}
-		else
-		{
-			int index;
-			
-			// Finally check whether this pak's checksum is listed because the user tried
-			// to trick us by renaming the file, and set foundPak's highest bit to indicate this case.
-			
-			for(index = 0; index < ARRAY_LEN(pak_checksums); index++)
-			{
-				if(curpack->checksum == pak_checksums[index])
-				{
-					Com_Printf("\n\n"
-						"**************************************************\n"
-						"WARNING: %s is renamed pak file %s%cpak%d.pk3\n"
-						"Running in standalone mode won't work\n"
-						"Please rename, or remove this file\n"
-						"**************************************************\n\n\n",
-						curpack->pakFilename, BASEGAME, PATH_SEP, index);
-
-
-					foundPak |= 0x80000000;
-				}
-			}
-
-			for(index = 0; index < ARRAY_LEN(missionpak_checksums); index++)
-			{
-				if(curpack->checksum == missionpak_checksums[index])
-				{
-					Com_Printf("\n\n"
-						"**************************************************\n"
-						"WARNING: %s is renamed pak file %s%cpak%d.pk3\n"
-						"Running in standalone mode won't work\n"
-						"Please rename, or remove this file\n"
-						"**************************************************\n\n\n",
-						curpack->pakFilename, BASETA, PATH_SEP, index);
-
-					foundTA |= 0x80000000;
-				}
-			}
-		}
-	}
-
-	if(!foundPak && !foundTA && Q_stricmp(com_basegame->string, BASEGAME))
-	{
-		Cvar_Set("com_standalone", "1");
-	}
-	else
-		Cvar_Set("com_standalone", "0");
-
-	if(!com_standalone->integer)
-	{
-		if(!(foundPak & 0x01))
-		{
-			if(founddemo)
-			{
-				Com_Printf( "\n\n"
-						"**************************************************\n"
-						"WARNING: It looks like you're using pak0.pk3\n"
-						"from the demo. This may work fine, but it is not\n"
-						"guaranteed or supported.\n"
-						"**************************************************\n\n\n" );
-				
-				foundPak |= 0x01;
-			}
-		}
-	}
-
-
-	if(!com_standalone->integer && (foundPak & 0x1ff) != 0x1ff)
-	{
-		char errorText[MAX_STRING_CHARS] = "";
-
-		if((foundPak & 0x01) != 0x01)
-		{
-			Q_strcat(errorText, sizeof(errorText),
-				"\"pak0.pk3\" is missing. Please copy it "
-				"from your legitimate Q3 CDROM. ");
-		}
-
-		if((foundPak & 0x1fe) != 0x1fe)
-		{
-			Q_strcat(errorText, sizeof(errorText),
-				"Point Release files are missing. Please "
-				"re-install the 1.32 point release. ");
-		}
-
-		Q_strcat(errorText, sizeof(errorText),
-			va("Also check that your ioq3 executable is in "
-			"the correct place and that every file "
-			"in the \"%s\" directory is present and readable", BASEGAME));
-
-		Com_Error(ERR_FATAL, "%s", errorText);
-	}
-	
-	if(!com_standalone->integer && foundTA && (foundTA & 0x0f) != 0x0f)
-	{
-		char errorText[MAX_STRING_CHARS] = "";
-
-		if((foundTA & 0x01) != 0x01)
-		{
-			Com_sprintf(errorText, sizeof(errorText),
-				"\"" BASETA "%cpak0.pk3\" is missing. Please copy it "
-				"from your legitimate Quake 3 Team Arena CDROM. ", PATH_SEP);
-		}
-
-		if((foundTA & 0x0e) != 0x0e)
-		{
-			Q_strcat(errorText, sizeof(errorText),
-				"Team Arena Point Release files are missing. Please "
-				"re-install the latest Team Arena point release.");
-		}
-
-		Com_Error(ERR_FATAL, "%s", errorText);
-	}
-}
-#endif
-
-/*
-=====================
-FS_LoadedPakChecksums
-
-Returns a space separated string containing the checksums of all loaded pk3 files.
-Servers with sv_pure set will get this string and pass it to clients.
-=====================
-*/
-const char *FS_LoadedPakChecksums( void ) {
-	static char	info[BIG_INFO_STRING];
-	searchpath_t	*search;
-
-	info[0] = 0;
-
-	for ( search = fs_searchpaths ; search ; search = search->next ) {
-		// is the element a pak file? 
-		if ( !search->pack ) {
-			continue;
-		}
-
-		Q_strcat( info, sizeof( info ), va("%i ", search->pack->checksum ) );
-	}
-
-	return info;
-}
-
-/*
-=====================
-FS_LoadedPakNames
-
-Returns a space separated string containing the names of all loaded pk3 files.
-Servers with sv_pure set will get this string and pass it to clients.
-=====================
-*/
-const char *FS_LoadedPakNames( void ) {
-	static char	info[BIG_INFO_STRING];
-	searchpath_t	*search;
-
-	info[0] = 0;
-
-	for ( search = fs_searchpaths ; search ; search = search->next ) {
-		// is the element a pak file?
-		if ( !search->pack ) {
-			continue;
-		}
-
-		if (*info) {
-			Q_strcat(info, sizeof( info ), " " );
-		}
-		Q_strcat( info, sizeof( info ), search->pack->pakBasename );
-	}
-
-	return info;
-}
-
-/*
-=====================
-FS_LoadedPakPureChecksums
-
-Returns a space separated string containing the pure checksums of all loaded pk3 files.
-Servers with sv_pure use these checksums to compare with the checksums the clients send
-back to the server.
-=====================
-*/
-const char *FS_LoadedPakPureChecksums( void ) {
-	static char	info[BIG_INFO_STRING];
-	searchpath_t	*search;
-
-	info[0] = 0;
-
-	for ( search = fs_searchpaths ; search ; search = search->next ) {
-		// is the element a pak file? 
-		if ( !search->pack ) {
-			continue;
-		}
-
-		Q_strcat( info, sizeof( info ), va("%i ", search->pack->pure_checksum ) );
-	}
-
-	return info;
-}
-
-/*
-=====================
-FS_ReferencedPakChecksums
-
-Returns a space separated string containing the checksums of all referenced pk3 files.
-The server will send this to the clients so they can check which files should be auto-downloaded. 
-=====================
-*/
-const char *FS_ReferencedPakChecksums( void ) {
-	static char	info[BIG_INFO_STRING];
-	searchpath_t *search;
-
-	info[0] = 0;
-
-
-	for ( search = fs_searchpaths ; search ; search = search->next ) {
-		// is the element a pak file?
-		if ( search->pack ) {
-			if (search->pack->referenced || Q_stricmpn(search->pack->pakGamename, com_basegame->string, strlen(com_basegame->string))) {
-				Q_strcat( info, sizeof( info ), va("%i ", search->pack->checksum ) );
-			}
-		}
-	}
-
-	return info;
-}
-
-/*
-=====================
-FS_ReferencedPakPureChecksums
-
-Returns a space separated string containing the pure checksums of all referenced pk3 files.
-Servers with sv_pure set will get this string back from clients for pure validation 
-
-The string has a specific order, "cgame ui @ ref1 ref2 ref3 ..."
-=====================
-*/
-const char *FS_ReferencedPakPureChecksums( void ) {
-	static char	info[BIG_INFO_STRING];
-	searchpath_t	*search;
-	int nFlags, numPaks, checksum;
-
-	info[0] = 0;
-
-	checksum = fs_checksumFeed;
-	numPaks = 0;
-	for (nFlags = FS_CGAME_REF; nFlags; nFlags = nFlags >> 1) {
-		if (nFlags & FS_GENERAL_REF) {
-			// add a delimter between must haves and general refs
-			//Q_strcat(info, sizeof(info), "@ ");
-			info[strlen(info)+1] = '\0';
-			info[strlen(info)+2] = '\0';
-			info[strlen(info)] = '@';
-			info[strlen(info)] = ' ';
-		}
-		for ( search = fs_searchpaths ; search ; search = search->next ) {
-			// is the element a pak file and has it been referenced based on flag?
-			if ( search->pack && (search->pack->referenced & nFlags)) {
-				Q_strcat( info, sizeof( info ), va("%i ", search->pack->pure_checksum ) );
-				if (nFlags & (FS_CGAME_REF | FS_UI_REF)) {
-					break;
-				}
-				checksum ^= search->pack->pure_checksum;
-				numPaks++;
-			}
-		}
-	}
-	// last checksum is the encoded number of referenced pk3s
-	checksum ^= numPaks;
-	Q_strcat( info, sizeof( info ), va("%i ", checksum ) );
-
-	return info;
-}
-
-/*
-=====================
-FS_ReferencedPakNames
-
-Returns a space separated string containing the names of all referenced pk3 files.
-The server will send this to the clients so they can check which files should be auto-downloaded. 
-=====================
-*/
-const char *FS_ReferencedPakNames( void ) {
-	static char	info[BIG_INFO_STRING];
-	searchpath_t	*search;
-
-	info[0] = 0;
-
-	// we want to return ALL pk3's from the fs_game path
-	// and referenced one's from baseq3
-	for ( search = fs_searchpaths ; search ; search = search->next ) {
-		// is the element a pak file?
-		if ( search->pack ) {
-			if (search->pack->referenced || Q_stricmpn(search->pack->pakGamename, com_basegame->string, strlen(com_basegame->string))) {
-				if (*info) {
-					Q_strcat(info, sizeof( info ), " " );
-				}
-				Q_strcat( info, sizeof( info ), search->pack->pakGamename );
-				Q_strcat( info, sizeof( info ), "/" );
-				Q_strcat( info, sizeof( info ), search->pack->pakBasename );
-			}
-		}
-	}
-
-	return info;
-}
-
-/*
-=====================
-FS_ClearPakReferences
-=====================
-*/
-void FS_ClearPakReferences( int flags ) {
-	searchpath_t *search;
-
-	if ( !flags ) {
-		flags = -1;
-	}
-	for ( search = fs_searchpaths; search; search = search->next ) {
-		// is the element a pak file and has it been referenced?
-		if ( search->pack ) {
-			search->pack->referenced &= ~flags;
-		}
-	}
-}
-
-
-/*
-=====================
-FS_PureServerSetLoadedPaks
-
-If the string is empty, all data sources will be allowed.
-If not empty, only pk3 files that match one of the space
-separated checksums will be checked for files, with the
-exception of .cfg and .dat files.
-=====================
-*/
-void FS_PureServerSetLoadedPaks( const char *pakSums, const char *pakNames ) {
-	int		i, c, d;
-
-	Cmd_TokenizeString( pakSums );
-
-	c = Cmd_Argc();
-	if ( c > MAX_SEARCH_PATHS ) {
-		c = MAX_SEARCH_PATHS;
-	}
-
-	fs_numServerPaks = c;
-
-	for ( i = 0 ; i < c ; i++ ) {
-		fs_serverPaks[i] = atoi( Cmd_Argv( i ) );
-	}
-
-	if (fs_numServerPaks) {
-		Com_DPrintf( "Connected to a pure server.\n" );
-	}
-	else
-	{
-		if (fs_reordered)
-		{
-			// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=540
-			// force a restart to make sure the search order will be correct
-			Com_DPrintf( "FS search reorder is required\n" );
-			FS_Restart(fs_checksumFeed);
-			return;
-		}
-	}
-
-	for ( i = 0 ; i < c ; i++ ) {
-		if (fs_serverPakNames[i]) {
-			Z_Free(fs_serverPakNames[i]);
-		}
-		fs_serverPakNames[i] = NULL;
-	}
-	if ( pakNames && *pakNames ) {
-		Cmd_TokenizeString( pakNames );
-
-		d = Cmd_Argc();
-		if ( d > MAX_SEARCH_PATHS ) {
-			d = MAX_SEARCH_PATHS;
-		}
-
-		for ( i = 0 ; i < d ; i++ ) {
-			fs_serverPakNames[i] = CopyString( Cmd_Argv( i ) );
-		}
-	}
-}
-
-/*
-=====================
-FS_PureServerSetReferencedPaks
-
-The checksums and names of the pk3 files referenced at the server
-are sent to the client and stored here. The client will use these
-checksums to see if any pk3 files need to be auto-downloaded. 
-=====================
-*/
-void FS_PureServerSetReferencedPaks( const char *pakSums, const char *pakNames ) {
-	int		i, c, d = 0;
-
-	Cmd_TokenizeString( pakSums );
-
-	c = Cmd_Argc();
-	if ( c > MAX_SEARCH_PATHS ) {
-		c = MAX_SEARCH_PATHS;
-	}
-
-	for ( i = 0 ; i < c ; i++ ) {
-		fs_serverReferencedPaks[i] = atoi( Cmd_Argv( i ) );
-	}
-
-	for (i = 0 ; i < ARRAY_LEN(fs_serverReferencedPakNames); i++)
-	{
-		if(fs_serverReferencedPakNames[i])
-			Z_Free(fs_serverReferencedPakNames[i]);
-
-		fs_serverReferencedPakNames[i] = NULL;
-	}
-
-	if ( pakNames && *pakNames ) {
-		Cmd_TokenizeString( pakNames );
-
-		d = Cmd_Argc();
-
-		if(d > c)
-			d = c;
-
-		for ( i = 0 ; i < d ; i++ ) {
-			fs_serverReferencedPakNames[i] = CopyString( Cmd_Argv( i ) );
-		}
-	}
-	
-	// ensure that there are as many checksums as there are pak names.
-	if(d < c)
-		c = d;
-	
-	fs_numServerReferencedPaks = c;	
-}
-
-static vfsAPI_s g_staticVFSAPI;
-vfsAPI_s *g_vfs = 0;
-void FS_InitAPI() {
-	g_staticVFSAPI.FS_FOpenFile = FS_FOpenFileByMode;
-	g_staticVFSAPI.FS_Read = FS_Read;
-	g_staticVFSAPI.FS_Write = FS_Write;
-	g_staticVFSAPI.FS_FCloseFile = FS_FCloseFile;
-	g_staticVFSAPI.FS_GetFileList = FS_GetFileList;
-	g_staticVFSAPI.FS_Seek = FS_Seek;
-	g_staticVFSAPI.FS_ListFiles = FS_ListFiles;
-	g_staticVFSAPI.FS_FreeFileList = FS_FreeFileList;
-	g_staticVFSAPI.FS_ReadFile = FS_ReadFile;
-	g_staticVFSAPI.FS_FreeFile = FS_FreeFile;
-
-	g_vfs = &g_staticVFSAPI;
-	g_iFaceMan->registerInterface(&g_staticVFSAPI,VFS_API_IDENTSTR);
-}
-
-/*
-================
-FS_InitFilesystem
-
-Called only at inital startup, not when the filesystem
-is resetting due to a game change
-================
-*/
-void FS_InitFilesystem( void ) {
-	// allow command line parms to override our defaults
-	// we have to specially handle this, because normal command
-	// line variable sets don't happen until after the filesystem
-	// has already been initialized
-	Com_StartupVariable("fs_basepath");
-	Com_StartupVariable("fs_homepath");
-	Com_StartupVariable("fs_game");
-
-	if(!FS_FilenameCompare(Cvar_VariableString("fs_game"), com_basegame->string))
-		Cvar_Set("fs_game", "");
-
-	// try to start up normally
-	FS_Startup(com_basegame->string);
-
-	FS_InitAPI();
-
-#ifndef STANDALONE
-	FS_CheckPak0( );
-#endif
-
-	// if we can't find default.cfg, assume that the paths are
-	// busted and error out now, rather than getting an unreadable
-	// graphics screen when the font fails to load
-	if ( FS_ReadFile( "default.cfg", NULL ) <= 0 ) {
-		Com_Error( ERR_FATAL, "Couldn't load default.cfg" );
-	}
-
-	Q_strncpyz(lastValidBase, fs_basepath->string, sizeof(lastValidBase));
-	Q_strncpyz(lastValidGame, fs_gamedirvar->string, sizeof(lastValidGame));
-}
-
-
-/*
-================
-FS_Restart
-================
-*/
-void FS_Restart( int checksumFeed ) {
-
-	// free anything we currently have loaded
-	FS_Shutdown(qfalse);
-
-	// set the checksum feed
-	fs_checksumFeed = checksumFeed;
-
-	// clear pak references
-	FS_ClearPakReferences(0);
-
-	// try to start up normally
-	FS_Startup(com_basegame->string);
-
-#ifndef STANDALONE
-	FS_CheckPak0( );
-#endif
-
-	// if we can't find default.cfg, assume that the paths are
-	// busted and error out now, rather than getting an unreadable
-	// graphics screen when the font fails to load
-	if ( FS_ReadFile( "default.cfg", NULL ) <= 0 ) {
-		// this might happen when connecting to a pure server not using BASEGAME/pak0.pk3
-		// (for instance a TA demo server)
-		if (lastValidBase[0]) {
-			FS_PureServerSetLoadedPaks("", "");
-			Cvar_Set("fs_basepath", lastValidBase);
-			Cvar_Set("fs_gamedirvar", lastValidGame);
-			lastValidBase[0] = '\0';
-			lastValidGame[0] = '\0';
-			FS_Restart(checksumFeed);
-			Com_Error( ERR_DROP, "Invalid game folder" );
-			return;
-		}
-		Com_Error( ERR_FATAL, "Couldn't load default.cfg" );
-	}
-
-	if ( Q_stricmp(fs_gamedirvar->string, lastValidGame) ) {
-		// skip the qioconfig.cfg if "safe" is on the command line
-		if ( !Com_SafeMode() ) {
-			Cbuf_AddText ("exec " QIOCONFIG_CFG "\n");
-		}
-	}
-
-	Q_strncpyz(lastValidBase, fs_basepath->string, sizeof(lastValidBase));
-	Q_strncpyz(lastValidGame, fs_gamedirvar->string, sizeof(lastValidGame));
-
-}
-
-/*
-=================
-FS_ConditionalRestart
-
-Restart if necessary
-Return qtrue if restarting due to game directory changed, qfalse otherwise
-=================
-*/
-qboolean FS_ConditionalRestart(int checksumFeed, qboolean disconnect)
-{
-	if(fs_gamedirvar->modified)
-	{
-		if(FS_FilenameCompare(lastValidGame, fs_gamedirvar->string) &&
-		   (*lastValidGame || FS_FilenameCompare(fs_gamedirvar->string, com_basegame->string)) &&
-		   (*fs_gamedirvar->string || FS_FilenameCompare(lastValidGame, com_basegame->string)))
-		{
-			Com_GameRestart(checksumFeed, disconnect);
-			return qtrue;
-		}
-		else
-			fs_gamedirvar->modified = qfalse;
-	}
-	
-	if(checksumFeed != fs_checksumFeed)
-		FS_Restart(checksumFeed);
-	else if(fs_numServerPaks && !fs_reordered)
-		FS_ReorderPurePaks();
-	
-	return qfalse;
-}
-
-/*
-========================================================================================
-
-Handle based file calls for virtual machines
-
-========================================================================================
-*/
-
-int		FS_FOpenFileByMode( const char *qpath, fileHandle_t *f, fsMode_t mode ) {
-	int		r;
-	qboolean	sync;
-
-	sync = qfalse;
-
-	switch( mode ) {
-	case FS_READ:
-		r = FS_FOpenFileRead( qpath, f, qtrue );
-		break;
-	case FS_WRITE:
-		*f = FS_FOpenFileWrite( qpath );
-		r = 0;
-		if (*f == 0) {
-			r = -1;
-		}
-		break;
-	case FS_APPEND_SYNC:
-		sync = qtrue;
-	case FS_APPEND:
-		*f = FS_FOpenFileAppend( qpath );
-		r = 0;
-		if (*f == 0) {
-			r = -1;
-		}
-		break;
-	default:
-		Com_Error( ERR_FATAL, "FS_FOpenFileByMode: bad mode" );
-		return -1;
-	}
-
-	if (!f) {
-		return r;
-	}
-
-	if ( *f ) {
-		if (fsh[*f].zipFile == qtrue) {
-			fsh[*f].baseOffset = unztell(fsh[*f].handleFiles.file.z);
-		} else {
-			fsh[*f].baseOffset = ftell(fsh[*f].handleFiles.file.o);
-		}
-		fsh[*f].fileSize = r;
-		fsh[*f].streamed = qfalse;
-
-		if (mode == FS_READ) {
-			fsh[*f].streamed = qtrue;
-		}
-	}
-	fsh[*f].handleSync = sync;
-
-	return r;
-}
-
-int		FS_FTell( fileHandle_t f ) {
-	int pos;
-	if (fsh[f].zipFile == qtrue) {
-		pos = unztell(fsh[f].handleFiles.file.z);
-	} else {
-		pos = ftell(fsh[f].handleFiles.file.o);
-	}
-	return pos;
-}
-
-void	FS_Flush( fileHandle_t f ) {
-	fflush(fsh[f].handleFiles.file.o);
-}
-
-void	FS_FilenameCompletion( const char *dir, const char *ext,
-		qboolean stripExt, void(*callback)(const char *s), qboolean allowNonPureFilesOnDisk ) {
-	char	**filenames;
-	int		nfiles;
-	int		i;
-	char	filename[ MAX_STRING_CHARS ];
-
-	filenames = FS_ListFilteredFiles( dir, ext, NULL, &nfiles, allowNonPureFilesOnDisk );
-
-	FS_SortFileList( filenames, nfiles );
-
-	for( i = 0; i < nfiles; i++ ) {
-		FS_ConvertPath( filenames[ i ] );
-		Q_strncpyz( filename, filenames[ i ], MAX_STRING_CHARS );
-
-		if( stripExt ) {
-			COM_StripExtension(filename, filename, sizeof(filename));
-		}
-
-		callback( filename );
-	}
-	FS_FreeFileList( filenames );
-}
-
-const char *FS_GetCurrentGameDir(void)
-{
-	if(fs_gamedirvar->string[0])
-		return fs_gamedirvar->string;
-
-	return com_basegame->string;
-}
+// TODO: remove this file
\ No newline at end of file
Index: code/qcommon/md5.cpp
===================================================================
--- code/qcommon/md5.cpp	(revision 183)
+++ code/qcommon/md5.cpp	(working copy)
@@ -259,52 +259,53 @@
 
 char *Com_MD5File( const char *fn, int length, const char *prefix, int prefix_len )
 {
-	static char final[33] = {""};
-	unsigned char digest[16] = {""}; 
-	fileHandle_t f;
-	MD5_CTX md5;
-	byte buffer[2048];
-	int i;
-	int filelen = 0;
-	int r = 0;
-	int total = 0;
+	//static char final[33] = {""};
+	//unsigned char digest[16] = {""}; 
+	//vfsFileAPI_i * f;
+	//MD5_CTX md5;
+	//byte buffer[2048];
+	//int i;
+	//int filelen = 0;
+	//int r = 0;
+	//int total = 0;
 
-	Q_strncpyz( final, "", sizeof( final ) );
+	//Q_strncpyz( final, "", sizeof( final ) );
 
-	filelen = FS_SV_FOpenFileRead( fn, &f );
+	//filelen = FS_SV_FOpenFileRead( fn, &f );
 
-	if( !f ) {
-		return final;
-	}
-	if( filelen < 1 ) {
-		FS_FCloseFile( f );
-		return final;
-	}
-	if(filelen < length || !length) {
-		length = filelen;
-	}
+	//if( !f ) {
+	//	return final;
+	//}
+	//if( filelen < 1 ) {
+	//	FS_FCloseFile( f );
+	//	return final;
+	//}
+	//if(filelen < length || !length) {
+	//	length = filelen;
+	//}
 
-	MD5Init(&md5);
+	//MD5Init(&md5);
 
-	if( prefix_len && *prefix )
-		MD5Update(&md5 , (unsigned char *)prefix, prefix_len);
+	//if( prefix_len && *prefix )
+	//	MD5Update(&md5 , (unsigned char *)prefix, prefix_len);
 
-	for(;;) {
-		r = FS_Read2(buffer, sizeof(buffer), f);
-		if(r < 1)
-			break;
-		if(r + total > length)
-			r = length - total;
-		total += r;
-		MD5Update(&md5 , buffer, r);
-		if(r < sizeof(buffer) || total >= length)
-			break;
-	}
-	FS_FCloseFile(f);
-	MD5Final(&md5, digest);
-	final[0] = '\0';
-	for(i = 0; i < 16; i++) {
-		Q_strcat(final, sizeof(final), va("%02X", digest[i]));
-	}
-	return final;
+	//for(;;) {
+	//	r = FS_Read2(buffer, sizeof(buffer), f);
+	//	if(r < 1)
+	//		break;
+	//	if(r + total > length)
+	//		r = length - total;
+	//	total += r;
+	//	MD5Update(&md5 , buffer, r);
+	//	if(r < sizeof(buffer) || total >= length)
+	//		break;
+	//}
+	//FS_FCloseFile(f);
+	//MD5Final(&md5, digest);
+	//final[0] = '\0';
+	//for(i = 0; i < 16; i++) {
+	//	Q_strcat(final, sizeof(final), va("%02X", digest[i]));
+	//}
+	//return final;
+	return 0;
 }
Index: code/qcommon/q_shared.h
===================================================================
--- code/qcommon/q_shared.h	(revision 291)
+++ code/qcommon/q_shared.h	(working copy)
@@ -192,11 +192,6 @@
 	unsigned int ui;
 } floatint_t;
 
-typedef int		qhandle_t;
-typedef int		sfxHandle_t;
-typedef int		fileHandle_t;
-typedef int		clipHandle_t;
-
 #define PAD(base, alignment)	(((base)+(alignment)-1) & ~((alignment)-1))
 #define PADLEN(base, alignment)	(PAD((base), (alignment)) - (base))
 
@@ -907,13 +902,13 @@
 
 // the modules that run in the virtual machine can't access the cvar_s directly,
 // so they must ask for structured updates
-typedef struct {
+struct vmCvar_t {
 	cvarHandle_t	handle;
 	int			modificationCount;
 	float		value;
 	int			integer;
 	char		string[MAX_CVAR_VALUE_STRING];
-} vmCvar_t;
+};
 
 
 /*
@@ -1229,33 +1224,33 @@
 
 // font support 
 
-#define GLYPH_START 0
-#define GLYPH_END 255
-#define GLYPH_CHARSTART 32
-#define GLYPH_CHAREND 127
-#define GLYPHS_PER_FONT GLYPH_END - GLYPH_START + 1
-typedef struct {
-  int height;       // number of scan lines
-  int top;          // top of glyph in buffer
-  int bottom;       // bottom of glyph in buffer
-  int pitch;        // width for copying
-  int xSkip;        // x adjustment
-  int imageWidth;   // width of actual image
-  int imageHeight;  // height of actual image
-  float s;          // x offset in image where glyph starts
-  float t;          // y offset in image where glyph starts
-  float s2;
-  float t2;
-  qhandle_t glyph;  // handle to the shader with the glyph
-  char shaderName[32];
-} glyphInfo_t;
+//#define GLYPH_START 0
+//#define GLYPH_END 255
+//#define GLYPH_CHARSTART 32
+//#define GLYPH_CHAREND 127
+//#define GLYPHS_PER_FONT GLYPH_END - GLYPH_START + 1
+//typedef struct {
+//  int height;       // number of scan lines
+//  int top;          // top of glyph in buffer
+//  int bottom;       // bottom of glyph in buffer
+//  int pitch;        // width for copying
+//  int xSkip;        // x adjustment
+//  int imageWidth;   // width of actual image
+//  int imageHeight;  // height of actual image
+//  float s;          // x offset in image where glyph starts
+//  float t;          // y offset in image where glyph starts
+//  float s2;
+//  float t2;
+//  qhandle_t glyph;  // handle to the shader with the glyph
+//  char shaderName[32];
+//} glyphInfo_t;
+//
+//typedef struct {
+//  glyphInfo_t glyphs [GLYPHS_PER_FONT];
+//  float glyphScale;
+//  char name[MAX_QPATH];
+//} fontInfo_t;
 
-typedef struct {
-  glyphInfo_t glyphs [GLYPHS_PER_FONT];
-  float glyphScale;
-  char name[MAX_QPATH];
-} fontInfo_t;
-
 #define Square(x) ((x)*(x))
 
 // real time
Index: code/qcommon/qcommon.h
===================================================================
--- code/qcommon/qcommon.h	(revision 183)
+++ code/qcommon/qcommon.h	(working copy)
@@ -488,7 +488,7 @@
 // command.  Returns true if the command was a variable reference that
 // was handled. (print or change)
 
-void 	Cvar_WriteVariables( fileHandle_t f );
+void 	Cvar_WriteVariables( class vfsFileAPI_i * f );
 // writes lines containing "set variable value" for all variables
 // with the archive flag set to true.
 
@@ -515,166 +515,6 @@
 /*
 ==============================================================
 
-FILESYSTEM
-
-No stdio calls should be used by any part of the game, because
-we need to deal with all sorts of directory and seperator char
-issues.
-==============================================================
-*/
-
-// referenced flags
-// these are in loop specific order so don't change the order
-#define FS_GENERAL_REF	0x01
-#define FS_UI_REF		0x02
-#define FS_CGAME_REF	0x04
-// number of id paks that will never be autodownloaded from baseq3/missionpack
-#define NUM_ID_PAKS		9
-#define NUM_TA_PAKS		4
-
-#define	MAX_FILE_HANDLES	64
-
-#ifdef DEDICATED
-#	define QIOCONFIG_CFG "qioconfig_server.cfg"
-#else
-#	define QIOCONFIG_CFG "qioconfig.cfg"
-#endif
-
-qboolean FS_Initialized( void );
-
-void	FS_InitFilesystem ( void );
-void	FS_Shutdown( qboolean closemfp );
-
-qboolean FS_ConditionalRestart(int checksumFeed, qboolean disconnect);
-void	FS_Restart( int checksumFeed );
-// shutdown and restart the filesystem so changes to fs_gamedir can take effect
-
-void FS_AddGameDirectory( const char *path, const char *dir );
-
-char	**FS_ListFiles( const char *directory, const char *extension, int *numfiles );
-// directory should not have either a leading or trailing /
-// if extension is "/", only subdirectories will be returned
-// the returned files will not include any directories or /
-
-void	FS_FreeFileList( char **list );
-
-qboolean FS_FileExists( const char *file );
-
-qboolean FS_CreatePath (char *OSPath);
-
-char   *FS_BuildOSPath( const char *base, const char *game, const char *qpath );
-qboolean FS_CompareZipChecksum(const char *zipfile);
-
-int		FS_LoadStack( void );
-
-int		FS_GetFileList(  const char *path, const char *extension, char *listbuf, int bufsize );
-int		FS_GetModList(  char *listbuf, int bufsize );
-
-fileHandle_t	FS_FOpenFileWrite( const char *qpath );
-fileHandle_t	FS_FOpenFileAppend( const char *filename );
-fileHandle_t	FS_FCreateOpenPipeFile( const char *filename );
-// will properly create any needed paths and deal with seperater character issues
-
-fileHandle_t FS_SV_FOpenFileWrite( const char *filename );
-long		FS_SV_FOpenFileRead( const char *filename, fileHandle_t *fp );
-void	FS_SV_Rename( const char *from, const char *to );
-long		FS_FOpenFileRead( const char *qpath, fileHandle_t *file, qboolean uniqueFILE );
-// if uniqueFILE is true, then a new FILE will be fopened even if the file
-// is found in an already open pak file.  If uniqueFILE is false, you must call
-// FS_FCloseFile instead of fclose, otherwise the pak FILE would be improperly closed
-// It is generally safe to always set uniqueFILE to true, because the majority of
-// file IO goes through FS_ReadFile, which Does The Right Thing already.
-
-int		FS_FileIsInPAK(const char *filename, int *pChecksum );
-// returns 1 if a file is in the PAK file, otherwise -1
-
-int		FS_Write( const void *buffer, int len, fileHandle_t f );
-
-int		FS_Read2( void *buffer, int len, fileHandle_t f );
-int		FS_Read( void *buffer, int len, fileHandle_t f );
-// properly handles partial reads and reads from other dlls
-
-void	FS_FCloseFile( fileHandle_t f );
-// note: you can't just fclose from another DLL, due to MS libc issues
-
-long	FS_ReadFileDir(const char *qpath, void *searchPath, qboolean unpure, void **buffer);
-long	FS_ReadFile(const char *qpath, void **buffer);
-// returns the length of the file
-// a null buffer will just return the file length without loading
-// as a quick check for existance. -1 length == not present
-// A 0 byte will always be appended at the end, so string ops are safe.
-// the buffer should be considered read-only, because it may be cached
-// for other uses.
-
-void	FS_ForceFlush( fileHandle_t f );
-// forces flush on files we're writing to.
-
-void	FS_FreeFile( void *buffer );
-// frees the memory returned by FS_ReadFile
-
-void	FS_WriteFile( const char *qpath, const void *buffer, int size );
-// writes a complete file, creating any subdirectories needed
-
-long FS_filelength(fileHandle_t f);
-// doesn't work for files that are opened from a pack file
-
-int		FS_FTell( fileHandle_t f );
-// where are we?
-
-void	FS_Flush( fileHandle_t f );
-
-void 	QDECL FS_Printf( fileHandle_t f, const char *fmt, ... ) __attribute__ ((format (printf, 2, 3)));
-// like fprintf
-
-int		FS_FOpenFileByMode( const char *qpath, fileHandle_t *f, fsMode_t mode );
-// opens a file for reading, writing, or appending depending on the value of mode
-
-int		FS_Seek( fileHandle_t f, long offset, int origin );
-// seek on a file (doesn't work for zip files!!!!!!!!)
-
-qboolean FS_FilenameCompare( const char *s1, const char *s2 );
-
-const char *FS_LoadedPakNames( void );
-const char *FS_LoadedPakChecksums( void );
-const char *FS_LoadedPakPureChecksums( void );
-// Returns a space separated string containing the checksums of all loaded pk3 files.
-// Servers with sv_pure set will get this string and pass it to clients.
-
-const char *FS_ReferencedPakNames( void );
-const char *FS_ReferencedPakChecksums( void );
-const char *FS_ReferencedPakPureChecksums( void );
-// Returns a space separated string containing the checksums of all loaded 
-// AND referenced pk3 files. Servers with sv_pure set will get this string 
-// back from clients for pure validation 
-
-void FS_ClearPakReferences( int flags );
-// clears referenced booleans on loaded pk3s
-
-void FS_PureServerSetReferencedPaks( const char *pakSums, const char *pakNames );
-void FS_PureServerSetLoadedPaks( const char *pakSums, const char *pakNames );
-// If the string is empty, all data sources will be allowed.
-// If not empty, only pk3 files that match one of the space
-// separated checksums will be checked for files, with the
-// sole exception of .cfg files.
-
-qboolean FS_CheckDirTraversal(const char *checkdir);
-qboolean FS_idPak(char *pak, char *base, int numPaks);
-qboolean FS_ComparePaks( char *neededpaks, int len, qboolean dlstring );
-
-void FS_Rename( const char *from, const char *to );
-
-void FS_Remove( const char *osPath );
-void FS_HomeRemove( const char *homePath );
-
-void	FS_FilenameCompletion( const char *dir, const char *ext,
-		qboolean stripExt, void(*callback)(const char *s), qboolean allowNonPureFilesOnDisk );
-
-const char *FS_GetCurrentGameDir(void);
-qboolean FS_Which(const char *filename, void *searchPath);
-
-/*
-==============================================================
-
 Edit fields and command line history/completion
 
 ==============================================================
@@ -820,8 +660,8 @@
 extern	qboolean	com_errorEntered;
 extern	qboolean	com_fullyInitialized;
 
-extern	fileHandle_t	com_journalFile;
-extern	fileHandle_t	com_journalDataFile;
+extern	vfsFileAPI_i *	com_journalFile;
+extern	vfsFileAPI_i *	com_journalDataFile;
 
 typedef enum {
 	TAG_FREE,
@@ -955,7 +795,7 @@
 void Key_KeynameCompletion( void(*callback)(const char *s) );
 // for keyname autocompletion
 
-void Key_WriteBindings( fileHandle_t f );
+void Key_WriteBindings( vfsFileAPI_i * f );
 // for writing the config files
 
 void S_ClearSoundBuffer( void );
Index: code/renderer/backEndDX10/backEndDX10API.cpp
===================================================================
--- code/renderer/backEndDX10/backEndDX10API.cpp	(revision 294)
+++ code/renderer/backEndDX10/backEndDX10API.cpp	(working copy)
@@ -58,7 +58,7 @@
 // interface manager (import)
 class iFaceMgrAPI_i *g_iFaceMan = 0;
 // imports
-vfsAPI_s *g_vfs = 0;
+vfsAPI_i *g_vfs = 0;
 cvarsAPI_s *g_cvars = 0;
 coreAPI_s *g_core = 0;
 inputSystemAPI_i * g_inputSystem = 0;
Index: code/renderer/backEndDX9/backEndDX9API.cpp
===================================================================
--- code/renderer/backEndDX9/backEndDX9API.cpp	(revision 294)
+++ code/renderer/backEndDX9/backEndDX9API.cpp	(working copy)
@@ -70,7 +70,7 @@
 // interface manager (import)
 class iFaceMgrAPI_i *g_iFaceMan = 0;
 // imports
-vfsAPI_s *g_vfs = 0;
+vfsAPI_i *g_vfs = 0;
 cvarsAPI_s *g_cvars = 0;
 coreAPI_s *g_core = 0;
 inputSystemAPI_i * g_inputSystem = 0;
Index: code/renderer/backEndDX9/dx9_shader.cpp
===================================================================
--- code/renderer/backEndDX9/dx9_shader.cpp	(revision 273)
+++ code/renderer/backEndDX9/dx9_shader.cpp	(working copy)
@@ -58,7 +58,7 @@
 	fname.append(baseName);
 	fname.append(".fx");
 	char *fileData;
-	int len = g_vfs->FS_ReadFile(fname,(void**)&fileData);
+	u32 len = g_vfs->loadFileData(fname,(byte**)&fileData);
 	if(fileData == 0) {
 		return 0; // cannot open
 	}
@@ -80,7 +80,7 @@
 	}
 	finalEffectDef.append(fileData);
 	HRESULT hr = D3DXCreateEffect(pDev,finalEffectDef.c_str(),finalEffectDef.length(),0,0,dwShaderFlags,0,&ret->effect,&pCompilationErrors);
-	g_vfs->FS_FreeFile(fileData);
+	g_vfs->freeFileData((byte**)&fileData);
     if (FAILED(hr)) {
 		g_core->RedWarning("D3DXCreateEffect: failed for %s\n",fname.c_str());
     }
Index: code/renderer/backEndGL/backEndGLAPI.cpp
===================================================================
--- code/renderer/backEndGL/backEndGLAPI.cpp	(revision 261)
+++ code/renderer/backEndGL/backEndGLAPI.cpp	(working copy)
@@ -34,7 +34,7 @@
 // interface manager (import)
 class iFaceMgrAPI_i *g_iFaceMan = 0;
 // imports
-vfsAPI_s *g_vfs = 0;
+vfsAPI_i *g_vfs = 0;
 cvarsAPI_s *g_cvars = 0;
 coreAPI_s *g_core = 0;
 inputSystemAPI_i * g_inputSystem = 0;
Index: code/renderer/backEndGL/gl_shader.cpp
===================================================================
--- code/renderer/backEndGL/gl_shader.cpp	(revision 273)
+++ code/renderer/backEndGL/gl_shader.cpp	(working copy)
@@ -48,12 +48,12 @@
 
 bool GL_AppendFileTextToString(str &out, const char *fname) {
 	char *fileData;
-	int len = g_vfs->FS_ReadFile(fname,(void**)&fileData);
+	u32 len = g_vfs->loadFileData(fname,(byte**)&fileData);
 	if(fileData == 0) {
 		return true; // cannot open
 	}
 	out.append(fileData);
-	g_vfs->FS_FreeFile(fileData);
+	g_vfs->freeFileData((byte**)&fileData);
 	return false;
 }
 arraySTD_c<glShader_c*> gl_shaders;
@@ -102,11 +102,11 @@
 	ret->permutations = *permutations;
 	ret->name = baseName;
 	gl_shaders.push_back(ret);
-	if(g_vfs->FS_FileExists(fragFile) == false) {
+	if(g_vfs->fileExists(fragFile) == false) {
 		g_core->RedWarning("GL_RegisterShader: file %s does not exist\n",fragFile.c_str());
 		return 0;
 	}
-	if(g_vfs->FS_FileExists(vertFile) == false) {
+	if(g_vfs->fileExists(vertFile) == false) {
 		g_core->RedWarning("GL_RegisterShader: file %s does not exist\n",vertFile.c_str());
 		return 0;
 	}
Index: code/renderer/backEndNULL/backEndNULLAPI.cpp
===================================================================
--- code/renderer/backEndNULL/backEndNULLAPI.cpp	(revision 294)
+++ code/renderer/backEndNULL/backEndNULLAPI.cpp	(working copy)
@@ -33,7 +33,7 @@
 // interface manager (import)
 class iFaceMgrAPI_i *g_iFaceMan = 0;
 // imports
-vfsAPI_s *g_vfs = 0;
+vfsAPI_i *g_vfs = 0;
 cvarsAPI_s *g_cvars = 0;
 coreAPI_s *g_core = 0;
 inputSystemAPI_i * g_inputSystem = 0;
Index: code/renderer/frontend/rf_api.cpp
===================================================================
--- code/renderer/frontend/rf_api.cpp	(revision 271)
+++ code/renderer/frontend/rf_api.cpp	(working copy)
@@ -243,7 +243,7 @@
 // interface manager (import)
 class iFaceMgrAPI_i *g_iFaceMan = 0;
 // imports
-vfsAPI_s *g_vfs = 0;
+vfsAPI_i *g_vfs = 0;
 cvarsAPI_s *g_cvars = 0;
 coreAPI_s *g_core = 0;
 rbAPI_i *rb = 0;
Index: code/renderer/frontend/rf_bsp.cpp
===================================================================
--- code/renderer/frontend/rf_bsp.cpp	(revision 295)
+++ code/renderer/frontend/rf_bsp.cpp	(working copy)
@@ -903,6 +903,7 @@
 	arraySTD_c<byte> rgbs;
 
 	lightmapAllocator_c la;
+	// TODO: get max texture size from backend
 	la.init(1024);
 
 	surfs.resize(numSurfaces);
@@ -1020,7 +1021,6 @@
 	la.finalize();
 	oSF = surfs.getArray();
 	for(u32 i = 0; i < numSurfaces; i++, oSF++) {
-		oSF->type = BSPSF_PLANAR;
 		bspTriSurf_s *ts = oSF->sf;
 		if(ts->lightmap) {
 			u32 index = (u32)(ts->lightmap)-1;
@@ -1180,7 +1180,7 @@
 }
 bool rBspTree_c::load(const char *fname) {
 	fileData = 0;
-	u32 fileLen = g_vfs->FS_ReadFile(fname,(void**)&fileData);
+	u32 fileLen = g_vfs->loadFileData(fname,&fileData);
 	if(fileData == 0) {
 		g_core->Print(S_COLOR_RED "rBspTree_c::load: cannot open %s\n",fname);
 		return true;
@@ -1191,111 +1191,111 @@
 		if((h->version == BSP_VERSION_Q3 || h->version == BSP_VERSION_ET)) {
 			// Quake3 / ET / RTCW bsp
 			if(loadLightmaps(Q3_LIGHTMAPS)) {
-				g_vfs->FS_FreeFile(fileData);
+				g_vfs->freeFileData(&fileData);
 				return true; // error
 			}
 			if(loadSurfs(Q3_SURFACES, sizeof(q3Surface_s), Q3_DRAWINDEXES, Q3_DRAWVERTS, Q3_SHADERS, sizeof(q3BSPMaterial_s))) {
-				g_vfs->FS_FreeFile(fileData);
+				g_vfs->freeFileData(&fileData);
 				return true; // error
 			}
 			if(loadModels(Q3_MODELS)) {
-				g_vfs->FS_FreeFile(fileData);
+				g_vfs->freeFileData(&fileData);
 				return true; // error
 			}
 			if(loadNodesAndLeaves(Q3_NODES,Q3_LEAVES,sizeof(q3Leaf_s))) {
-				g_vfs->FS_FreeFile(fileData);
+				g_vfs->freeFileData(&fileData);
 				return true; // error
 			}
 			if(loadLeafIndexes(Q3_LEAFSURFACES)) {
-				g_vfs->FS_FreeFile(fileData);
+				g_vfs->freeFileData(&fileData);
 				return true; // error
 			}
 			if(loadPlanes(Q3_PLANES)) {
-				g_vfs->FS_FreeFile(fileData);
+				g_vfs->freeFileData(&fileData);
 				return true; // error
 			}
 			if(loadVisibility(Q3_VISIBILITY)) {
-				g_vfs->FS_FreeFile(fileData);
+				g_vfs->freeFileData(&fileData);
 				return true; // error
 			}
 		} else if(h->version == BSP_VERSION_Q2) {
 			// QuakeII bsp
 			if(loadPlanesQ2(Q2_PLANES)) {
-				g_vfs->FS_FreeFile(fileData);
+				g_vfs->freeFileData(&fileData);
 				return true; // error
 			}
 			if(loadNodesAndLeavesQ2(Q2_NODES,Q2_LEAFS)) {
-				g_vfs->FS_FreeFile(fileData);
+				g_vfs->freeFileData(&fileData);
 				return true; // error
 			}
 			if(loadModelsQ2(Q2_MODELS)) {
-				g_vfs->FS_FreeFile(fileData);
+				g_vfs->freeFileData(&fileData);
 				return true; // error
 			}
 			if(loadSurfsQ2()) {
-				g_vfs->FS_FreeFile(fileData);
+				g_vfs->freeFileData(&fileData);
 				return true; // error
 			}
 			if(loadLeafIndexes16Bit(Q2_LEAFFACES)) {
-				g_vfs->FS_FreeFile(fileData);
+				g_vfs->freeFileData(&fileData);
 				return true; // error
 			}
 		} else {
 			g_core->RedWarning("rBspTree_c::load: IBSP has unknown version %i\n",h->version);
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 	} else if(h->ident == BSP_IDENT_2015|| h->ident == BSP_IDENT_EALA) {
 		// MoHAA/MoHBT/MoHSH bsp file
 		if(loadLightmaps(MOH_LIGHTMAPS)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadSurfs(MOH_SURFACES, sizeof(q3Surface_s)+4, MOH_DRAWINDEXES, MOH_DRAWVERTS, MOH_SHADERS, sizeof(q3BSPMaterial_s)+64+4)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadModels(MOH_MODELS)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadNodesAndLeaves(MOH_NODES,MOH_LEAVES,sizeof(q3Leaf_s)+16)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadLeafIndexes(MOH_LEAFSURFACES)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadPlanes(MOH_PLANES)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadVisibility(MOH_VISIBILITY)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 	} else if(h->ident == BSP_IDENT_IBSP && h->version == BSP_VERSION_COD1) {
 		// Call Of Duty .bsp file
 		((q3Header_s*)h)->swapCoDLumpLenOfsValues();
 		if(loadModels(COD1_MODELS)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadSurfsCoD()) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadNodesAndLeaves(COD1_NODES,COD1_LEAFS,sizeof(cod1Leaf_s))) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadLeafIndexes(COD1_LEAFSURFACES)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadPlanes(COD1_PLANES)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		// temporary fix for Call of Duty bsp's.
@@ -1307,54 +1307,54 @@
 		// NOTE: HL_PLANES == Q2_PLANES.
 		// The plane_t struct is the same as well
 		if(loadPlanesQ2(HL_PLANES)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadNodesAndLeavesHL(HL_NODES,HL_LEAFS)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		// hl model_t struct is different from Q2
 		if(loadModelsHL(HL_MODELS)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadSurfsHL()) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadLeafIndexes16Bit(HL_MARKSURFACES)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 	} else if(h->ident == BSP_IDENT_VBSP) {
 		// SourceEngine plane struct is the same as in Q2/Q1
 		if(loadPlanesQ2(SRC_PLANES)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}		
 		if(loadModelsQ2(SRC_MODELS)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadLeafIndexes16Bit(SRC_LEAFFACES)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadNodesAndLeavesSE()) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadSurfsSE()) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 	} else {
 		g_core->RedWarning("rBspTree_c::load: unknown bsp type; cannot load %s\n",fname);
-		g_vfs->FS_FreeFile(fileData);
+		g_vfs->freeFileData(&fileData);
 		return true; // error
 	}
-	g_vfs->FS_FreeFile(fileData);
+	g_vfs->freeFileData(&fileData);
 	h = 0;
 	fileData = 0;
 
Index: code/server/server.h
===================================================================
--- code/server/server.h	(revision 291)
+++ code/server/server.h	(working copy)
@@ -147,7 +147,7 @@
 
 	// downloading
 	char			downloadName[MAX_QPATH]; // if not empty string, we are downloading
-	fileHandle_t	download;			// file being downloaded
+	vfsFileAPI_i *	download;			// file being downloaded
  	int				downloadSize;		// total bytes (can't use EOF because of paks)
  	int				downloadCount;		// bytes sent
 	int				downloadClientBlock;	// last block we sent to the client, awaiting ack
Index: code/server/sv_ccmds.cpp
===================================================================
--- code/server/sv_ccmds.cpp	(revision 240)
+++ code/server/sv_ccmds.cpp	(working copy)
@@ -22,6 +22,7 @@
 
 #include "server.h"
 #include <api/gameAPI.h>
+#include <api/vfsAPI.h>
 
 /*
 ===============================================================================
@@ -168,14 +169,14 @@
 		// make sure the level exists before trying to change, so that
 		// a typo at the server console won't end the game
 		Com_sprintf (expanded, sizeof(expanded), "maps/%s.bsp", map);
-		if ( FS_ReadFile (expanded, NULL) == -1 ) {
+		if (g_vfs->fileExists(expanded) == false) {
 			// we're supporting .map files as well
 			Com_sprintf (expanded, sizeof(expanded), "maps/%s.map", map);
-			if ( FS_ReadFile (expanded, NULL) == -1 ) {
+			if (g_vfs->fileExists(expanded) == false) {
 				// and ETQW .procb files (we dont have to check for D3 proc's because they 
 				// are always present with .map files)
 				Com_sprintf (expanded, sizeof(expanded), "maps/%s.procb", map);
-				if ( FS_ReadFile (expanded, NULL) == -1 ) {
+				if (g_vfs->fileExists(expanded) == false) {
 					Com_Printf ("SV_Map_f: Can't find map %s\n", map);
 					return;
 				}
@@ -644,77 +645,77 @@
 */
 static void SV_RehashBans_f(void)
 {
-	int index, filelen;
-	fileHandle_t readfrom;
-	char *textbuf, *curpos, *maskpos, *newlinepos, *endpos;
-	char filepath[MAX_QPATH];
-	
-	serverBansCount = 0;
-	
-	if(!sv_banFile->string || !*sv_banFile->string)
-		return;
+	//int index, filelen;
+	//vfsFileAPI_i * readfrom;
+	//char *textbuf, *curpos, *maskpos, *newlinepos, *endpos;
+	//char filepath[MAX_QPATH];
+	//
+	//serverBansCount = 0;
+	//
+	//if(!sv_banFile->string || !*sv_banFile->string)
+	//	return;
 
-	Com_sprintf(filepath, sizeof(filepath), "%s/%s", FS_GetCurrentGameDir(), sv_banFile->string);
+	//Com_sprintf(filepath, sizeof(filepath), "%s/%s", FS_GetCurrentGameDir(), sv_banFile->string);
 
-	if((filelen = FS_SV_FOpenFileRead(filepath, &readfrom)) >= 0)
-	{
-		if(filelen < 2)
-		{
-			// Don't bother if file is too short.
-			FS_FCloseFile(readfrom);
-			return;
-		}
+	//if((filelen = FS_SV_FOpenFileRead(filepath, &readfrom)) >= 0)
+	//{
+	//	if(filelen < 2)
+	//	{
+	//		// Don't bother if file is too short.
+	//		FS_FCloseFile(readfrom);
+	//		return;
+	//	}
 
-		curpos = textbuf = (char*)Z_Malloc(filelen);
-		
-		filelen = FS_Read(textbuf, filelen, readfrom);
-		FS_FCloseFile(readfrom);
-		
-		endpos = textbuf + filelen;
-		
-		for(index = 0; index < SERVER_MAXBANS && curpos + 2 < endpos; index++)
-		{
-			// find the end of the address string
-			for(maskpos = curpos + 2; maskpos < endpos && *maskpos != ' '; maskpos++);
-			
-			if(maskpos + 1 >= endpos)
-				break;
+	//	curpos = textbuf = (char*)Z_Malloc(filelen);
+	//	
+	//	filelen = FS_Read(textbuf, filelen, readfrom);
+	//	FS_FCloseFile(readfrom);
+	//	
+	//	endpos = textbuf + filelen;
+	//	
+	//	for(index = 0; index < SERVER_MAXBANS && curpos + 2 < endpos; index++)
+	//	{
+	//		// find the end of the address string
+	//		for(maskpos = curpos + 2; maskpos < endpos && *maskpos != ' '; maskpos++);
+	//		
+	//		if(maskpos + 1 >= endpos)
+	//			break;
 
-			*maskpos = '\0';
-			maskpos++;
-			
-			// find the end of the subnet specifier
-			for(newlinepos = maskpos; newlinepos < endpos && *newlinepos != '\n'; newlinepos++);
-			
-			if(newlinepos >= endpos)
-				break;
-			
-			*newlinepos = '\0';
-			
-			if(NET_StringToAdr(curpos + 2, &serverBans[index].ip, NA_UNSPEC))
-			{
-				serverBans[index].isexception = (curpos[0] != '0');
-				serverBans[index].subnet = atoi(maskpos);
-				
-				if(serverBans[index].ip.type == NA_IP &&
-				   (serverBans[index].subnet < 1 || serverBans[index].subnet > 32))
-				{
-					serverBans[index].subnet = 32;
-				}
-				else if(serverBans[index].ip.type == NA_IP6 &&
-					(serverBans[index].subnet < 1 || serverBans[index].subnet > 128))
-				{
-					serverBans[index].subnet = 128;
-				}
-			}
-			
-			curpos = newlinepos + 1;
-		}
-			
-		serverBansCount = index;
-		
-		Z_Free(textbuf);
-	}
+	//		*maskpos = '\0';
+	//		maskpos++;
+	//		
+	//		// find the end of the subnet specifier
+	//		for(newlinepos = maskpos; newlinepos < endpos && *newlinepos != '\n'; newlinepos++);
+	//		
+	//		if(newlinepos >= endpos)
+	//			break;
+	//		
+	//		*newlinepos = '\0';
+	//		
+	//		if(NET_StringToAdr(curpos + 2, &serverBans[index].ip, NA_UNSPEC))
+	//		{
+	//			serverBans[index].isexception = (curpos[0] != '0');
+	//			serverBans[index].subnet = atoi(maskpos);
+	//			
+	//			if(serverBans[index].ip.type == NA_IP &&
+	//			   (serverBans[index].subnet < 1 || serverBans[index].subnet > 32))
+	//			{
+	//				serverBans[index].subnet = 32;
+	//			}
+	//			else if(serverBans[index].ip.type == NA_IP6 &&
+	//				(serverBans[index].subnet < 1 || serverBans[index].subnet > 128))
+	//			{
+	//				serverBans[index].subnet = 128;
+	//			}
+	//		}
+	//		
+	//		curpos = newlinepos + 1;
+	//	}
+	//		
+	//	serverBansCount = index;
+	//	
+	//	Z_Free(textbuf);
+	//}
 }
 
 /*
@@ -726,8 +727,8 @@
 */
 static void SV_WriteBans(void)
 {
-	int index;
-	fileHandle_t writeto;
+	/*int index;
+	vfsFileAPI_i * writeto;
 	char filepath[MAX_QPATH];
 	
 	if(!sv_banFile->string || !*sv_banFile->string)
@@ -750,7 +751,7 @@
 		}
 
 		FS_FCloseFile(writeto);
-	}
+	}*/
 }
 
 /*
Index: code/server/sv_client.cpp
===================================================================
--- code/server/sv_client.cpp	(revision 284)
+++ code/server/sv_client.cpp	(working copy)
@@ -801,22 +801,22 @@
 ==================
 */
 static void SV_CloseDownload( client_t *cl ) {
-	int i;
+	//int i;
 
-	// EOF
-	if (cl->download) {
-		FS_FCloseFile( cl->download );
-	}
-	cl->download = 0;
-	*cl->downloadName = 0;
+	//// EOF
+	//if (cl->download) {
+	//	FS_FCloseFile( cl->download );
+	//}
+	//cl->download = 0;
+	//*cl->downloadName = 0;
 
-	// Free the temporary buffer space
-	for (i = 0; i < MAX_DOWNLOAD_WINDOW; i++) {
-		if (cl->downloadBlocks[i]) {
-			Z_Free(cl->downloadBlocks[i]);
-			cl->downloadBlocks[i] = NULL;
-		}
-	}
+	//// Free the temporary buffer space
+	//for (i = 0; i < MAX_DOWNLOAD_WINDOW; i++) {
+	//	if (cl->downloadBlocks[i]) {
+	//		Z_Free(cl->downloadBlocks[i]);
+	//		cl->downloadBlocks[i] = NULL;
+	//	}
+	//}
 
 }
 
@@ -903,200 +903,200 @@
 */
 int SV_WriteDownloadToClient(client_t *cl, msg_t *msg)
 {
-	int curindex;
-	int unreferenced = 1;
-	char errorMessage[1024];
-	char pakbuf[MAX_QPATH], *pakptr;
-	int numRefPaks;
+//	int curindex;
+//	int unreferenced = 1;
+//	char errorMessage[1024];
+//	char pakbuf[MAX_QPATH], *pakptr;
+//	int numRefPaks;
+//
+//	if (!*cl->downloadName)
+//		return 0;	// Nothing being downloaded
+//
+//	if(!cl->download)
+//	{
+//		qboolean idPack = qfalse;
+//		#ifndef STANDALONE
+//		qboolean missionPack = qfalse;
+//		#endif
+//	
+// 		// Chop off filename extension.
+//		Com_sprintf(pakbuf, sizeof(pakbuf), "%s", cl->downloadName);
+//		pakptr = strrchr(pakbuf, '.');
+//		
+//		if(pakptr)
+//		{
+//			*pakptr = '\0';
+//
+//			// Check for pk3 filename extension
+//			if(!Q_stricmp(pakptr + 1, "pk3"))
+//			{
+//				const char *referencedPaks = FS_ReferencedPakNames();
+//
+//				// Check whether the file appears in the list of referenced
+//				// paks to prevent downloading of arbitrary files.
+//				Cmd_TokenizeStringIgnoreQuotes(referencedPaks);
+//				numRefPaks = Cmd_Argc();
+//
+//				for(curindex = 0; curindex < numRefPaks; curindex++)
+//				{
+//					if(!FS_FilenameCompare(Cmd_Argv(curindex), pakbuf))
+//					{
+//						unreferenced = 0;
+//
+//						// now that we know the file is referenced,
+//						// check whether it's legal to download it.
+//#ifndef STANDALONE
+//						missionPack = FS_idPak(pakbuf, BASETA, NUM_TA_PAKS);
+//						idPack = missionPack;
+//#endif
+//						idPack = idPack || FS_idPak(pakbuf, BASEGAME, NUM_ID_PAKS);
+//
+//						break;
+//					}
+//				}
+//			}
+//		}
+//
+//		cl->download = 0;
+//unreferenced = 0; // HACK
+//		// We open the file here
+//		if ( !(sv_allowDownload->integer & DLF_ENABLE) ||
+//			(sv_allowDownload->integer & DLF_NO_UDP) ||
+//			idPack || unreferenced ||
+//			//( cl->downloadSize = FS_SV_FOpenFileRead( cl->downloadName, &cl->download ) ) < 0 ) {
+//			( cl->downloadSize = FS_FOpenFileRead( cl->downloadName, &cl->download, qtrue ) ) < 0 ) {
+//			// cannot auto-download file
+//			if(unreferenced)
+//			{
+//				Com_Printf("clientDownload: %d : \"%s\" is not referenced and cannot be downloaded.\n", (int) (cl - svs.clients), cl->downloadName);
+//				Com_sprintf(errorMessage, sizeof(errorMessage), "File \"%s\" is not referenced and cannot be downloaded.", cl->downloadName);
+//			}
+//			else if (idPack) {
+//				Com_Printf("clientDownload: %d : \"%s\" cannot download id pk3 files\n", (int) (cl - svs.clients), cl->downloadName);
+//#ifndef STANDALONE
+//				if(missionPack)
+//				{
+//					Com_sprintf(errorMessage, sizeof(errorMessage), "Cannot autodownload Team Arena file \"%s\"\n"
+//									"The Team Arena mission pack can be found in your local game store.", cl->downloadName);
+//				}
+//				else
+//#endif
+//				{
+//					Com_sprintf(errorMessage, sizeof(errorMessage), "Cannot autodownload id pk3 file \"%s\"", cl->downloadName);
+//				}
+//			}
+//			else if ( !(sv_allowDownload->integer & DLF_ENABLE) ||
+//				(sv_allowDownload->integer & DLF_NO_UDP) ) {
+//
+//				Com_Printf("clientDownload: %d : \"%s\" download disabled\n", (int) (cl - svs.clients), cl->downloadName);
+//				if (sv_pure->integer) {
+//					Com_sprintf(errorMessage, sizeof(errorMessage), "Could not download \"%s\" because autodownloading is disabled on the server.\n\n"
+//										"You will need to get this file elsewhere before you "
+//										"can connect to this pure server.\n", cl->downloadName);
+//				} else {
+//					Com_sprintf(errorMessage, sizeof(errorMessage), "Could not download \"%s\" because autodownloading is disabled on the server.\n\n"
+//                    "The server you are connecting to is not a pure server, "
+//                    "set autodownload to No in your settings and you might be "
+//                    "able to join the game anyway.\n", cl->downloadName);
+//				}
+//			} else {
+//        // NOTE TTimo this is NOT supposed to happen unless bug in our filesystem scheme?
+//        //   if the pk3 is referenced, it must have been found somewhere in the filesystem
+//				Com_Printf("clientDownload: %d : \"%s\" file not found on server\n", (int) (cl - svs.clients), cl->downloadName);
+//				Com_sprintf(errorMessage, sizeof(errorMessage), "File \"%s\" not found on server for autodownloading.\n", cl->downloadName);
+//			}
+//			MSG_WriteByte( msg, svc_download );
+//			MSG_WriteShort( msg, 0 ); // client is expecting block zero
+//			MSG_WriteLong( msg, -1 ); // illegal file size
+//			MSG_WriteString( msg, errorMessage );
+//
+//			*cl->downloadName = 0;
+//			
+//			if(cl->download)
+//				FS_FCloseFile(cl->download);
+//			
+//			return 0;
+//		}
+// 
+//		Com_Printf( "clientDownload: %d : beginning \"%s\"\n", (int) (cl - svs.clients), cl->downloadName );
+//		
+//		// Init
+//		cl->downloadCurrentBlock = cl->downloadClientBlock = cl->downloadXmitBlock = 0;
+//		cl->downloadCount = 0;
+//		cl->downloadEOF = qfalse;
+//	}
+//
+//	// Perform any reads that we need to
+//	while (cl->downloadCurrentBlock - cl->downloadClientBlock < MAX_DOWNLOAD_WINDOW &&
+//		cl->downloadSize != cl->downloadCount) {
+//
+//		curindex = (cl->downloadCurrentBlock % MAX_DOWNLOAD_WINDOW);
+//
+//		if (!cl->downloadBlocks[curindex])
+//			cl->downloadBlocks[curindex] = (byte*)Z_Malloc(MAX_DOWNLOAD_BLKSIZE);
+//
+//		cl->downloadBlockSize[curindex] = FS_Read( cl->downloadBlocks[curindex], MAX_DOWNLOAD_BLKSIZE, cl->download );
+//
+//		if (cl->downloadBlockSize[curindex] < 0) {
+//			// EOF right now
+//			cl->downloadCount = cl->downloadSize;
+//			break;
+//		}
+//
+//		cl->downloadCount += cl->downloadBlockSize[curindex];
+//
+//		// Load in next block
+//		cl->downloadCurrentBlock++;
+//	}
+//
+//	// Check to see if we have eof condition and add the EOF block
+//	if (cl->downloadCount == cl->downloadSize &&
+//		!cl->downloadEOF &&
+//		cl->downloadCurrentBlock - cl->downloadClientBlock < MAX_DOWNLOAD_WINDOW) {
+//
+//		cl->downloadBlockSize[cl->downloadCurrentBlock % MAX_DOWNLOAD_WINDOW] = 0;
+//		cl->downloadCurrentBlock++;
+//
+//		cl->downloadEOF = qtrue;  // We have added the EOF block
+//	}
+//
+//	if (cl->downloadClientBlock == cl->downloadCurrentBlock)
+//		return 0; // Nothing to transmit
+//
+//	// Write out the next section of the file, if we have already reached our window,
+//	// automatically start retransmitting
+//	if (cl->downloadXmitBlock == cl->downloadCurrentBlock)
+//	{
+//		// We have transmitted the complete window, should we start resending?
+//		if (svs.time - cl->downloadSendTime > 1000)
+//			cl->downloadXmitBlock = cl->downloadClientBlock;
+//		else
+//			return 0;
+//	}
+//
+//	// Send current block
+//	curindex = (cl->downloadXmitBlock % MAX_DOWNLOAD_WINDOW);
+//
+//	MSG_WriteByte( msg, svc_download );
+//	MSG_WriteShort( msg, cl->downloadXmitBlock );
+//
+//	// block zero is special, contains file size
+//	if ( cl->downloadXmitBlock == 0 )
+//		MSG_WriteLong( msg, cl->downloadSize );
+//
+//	MSG_WriteShort( msg, cl->downloadBlockSize[curindex] );
+//
+//	// Write the block
+//	if(cl->downloadBlockSize[curindex])
+//		MSG_WriteData(msg, cl->downloadBlocks[curindex], cl->downloadBlockSize[curindex]);
+//
+//	Com_DPrintf( "clientDownload: %d : writing block %d\n", (int) (cl - svs.clients), cl->downloadXmitBlock );
+//
+//	// Move on to the next block
+//	// It will get sent with next snap shot.  The rate will keep us in line.
+//	cl->downloadXmitBlock++;
+//	cl->downloadSendTime = svs.time;
 
-	if (!*cl->downloadName)
-		return 0;	// Nothing being downloaded
-
-	if(!cl->download)
-	{
-		qboolean idPack = qfalse;
-		#ifndef STANDALONE
-		qboolean missionPack = qfalse;
-		#endif
-	
- 		// Chop off filename extension.
-		Com_sprintf(pakbuf, sizeof(pakbuf), "%s", cl->downloadName);
-		pakptr = strrchr(pakbuf, '.');
-		
-		if(pakptr)
-		{
-			*pakptr = '\0';
-
-			// Check for pk3 filename extension
-			if(!Q_stricmp(pakptr + 1, "pk3"))
-			{
-				const char *referencedPaks = FS_ReferencedPakNames();
-
-				// Check whether the file appears in the list of referenced
-				// paks to prevent downloading of arbitrary files.
-				Cmd_TokenizeStringIgnoreQuotes(referencedPaks);
-				numRefPaks = Cmd_Argc();
-
-				for(curindex = 0; curindex < numRefPaks; curindex++)
-				{
-					if(!FS_FilenameCompare(Cmd_Argv(curindex), pakbuf))
-					{
-						unreferenced = 0;
-
-						// now that we know the file is referenced,
-						// check whether it's legal to download it.
-#ifndef STANDALONE
-						missionPack = FS_idPak(pakbuf, BASETA, NUM_TA_PAKS);
-						idPack = missionPack;
-#endif
-						idPack = idPack || FS_idPak(pakbuf, BASEGAME, NUM_ID_PAKS);
-
-						break;
-					}
-				}
-			}
-		}
-
-		cl->download = 0;
-unreferenced = 0; // HACK
-		// We open the file here
-		if ( !(sv_allowDownload->integer & DLF_ENABLE) ||
-			(sv_allowDownload->integer & DLF_NO_UDP) ||
-			idPack || unreferenced ||
-			//( cl->downloadSize = FS_SV_FOpenFileRead( cl->downloadName, &cl->download ) ) < 0 ) {
-			( cl->downloadSize = FS_FOpenFileRead( cl->downloadName, &cl->download, qtrue ) ) < 0 ) {
-			// cannot auto-download file
-			if(unreferenced)
-			{
-				Com_Printf("clientDownload: %d : \"%s\" is not referenced and cannot be downloaded.\n", (int) (cl - svs.clients), cl->downloadName);
-				Com_sprintf(errorMessage, sizeof(errorMessage), "File \"%s\" is not referenced and cannot be downloaded.", cl->downloadName);
-			}
-			else if (idPack) {
-				Com_Printf("clientDownload: %d : \"%s\" cannot download id pk3 files\n", (int) (cl - svs.clients), cl->downloadName);
-#ifndef STANDALONE
-				if(missionPack)
-				{
-					Com_sprintf(errorMessage, sizeof(errorMessage), "Cannot autodownload Team Arena file \"%s\"\n"
-									"The Team Arena mission pack can be found in your local game store.", cl->downloadName);
-				}
-				else
-#endif
-				{
-					Com_sprintf(errorMessage, sizeof(errorMessage), "Cannot autodownload id pk3 file \"%s\"", cl->downloadName);
-				}
-			}
-			else if ( !(sv_allowDownload->integer & DLF_ENABLE) ||
-				(sv_allowDownload->integer & DLF_NO_UDP) ) {
-
-				Com_Printf("clientDownload: %d : \"%s\" download disabled\n", (int) (cl - svs.clients), cl->downloadName);
-				if (sv_pure->integer) {
-					Com_sprintf(errorMessage, sizeof(errorMessage), "Could not download \"%s\" because autodownloading is disabled on the server.\n\n"
-										"You will need to get this file elsewhere before you "
-										"can connect to this pure server.\n", cl->downloadName);
-				} else {
-					Com_sprintf(errorMessage, sizeof(errorMessage), "Could not download \"%s\" because autodownloading is disabled on the server.\n\n"
-                    "The server you are connecting to is not a pure server, "
-                    "set autodownload to No in your settings and you might be "
-                    "able to join the game anyway.\n", cl->downloadName);
-				}
-			} else {
-        // NOTE TTimo this is NOT supposed to happen unless bug in our filesystem scheme?
-        //   if the pk3 is referenced, it must have been found somewhere in the filesystem
-				Com_Printf("clientDownload: %d : \"%s\" file not found on server\n", (int) (cl - svs.clients), cl->downloadName);
-				Com_sprintf(errorMessage, sizeof(errorMessage), "File \"%s\" not found on server for autodownloading.\n", cl->downloadName);
-			}
-			MSG_WriteByte( msg, svc_download );
-			MSG_WriteShort( msg, 0 ); // client is expecting block zero
-			MSG_WriteLong( msg, -1 ); // illegal file size
-			MSG_WriteString( msg, errorMessage );
-
-			*cl->downloadName = 0;
-			
-			if(cl->download)
-				FS_FCloseFile(cl->download);
-			
-			return 0;
-		}
- 
-		Com_Printf( "clientDownload: %d : beginning \"%s\"\n", (int) (cl - svs.clients), cl->downloadName );
-		
-		// Init
-		cl->downloadCurrentBlock = cl->downloadClientBlock = cl->downloadXmitBlock = 0;
-		cl->downloadCount = 0;
-		cl->downloadEOF = qfalse;
-	}
-
-	// Perform any reads that we need to
-	while (cl->downloadCurrentBlock - cl->downloadClientBlock < MAX_DOWNLOAD_WINDOW &&
-		cl->downloadSize != cl->downloadCount) {
-
-		curindex = (cl->downloadCurrentBlock % MAX_DOWNLOAD_WINDOW);
-
-		if (!cl->downloadBlocks[curindex])
-			cl->downloadBlocks[curindex] = (byte*)Z_Malloc(MAX_DOWNLOAD_BLKSIZE);
-
-		cl->downloadBlockSize[curindex] = FS_Read( cl->downloadBlocks[curindex], MAX_DOWNLOAD_BLKSIZE, cl->download );
-
-		if (cl->downloadBlockSize[curindex] < 0) {
-			// EOF right now
-			cl->downloadCount = cl->downloadSize;
-			break;
-		}
-
-		cl->downloadCount += cl->downloadBlockSize[curindex];
-
-		// Load in next block
-		cl->downloadCurrentBlock++;
-	}
-
-	// Check to see if we have eof condition and add the EOF block
-	if (cl->downloadCount == cl->downloadSize &&
-		!cl->downloadEOF &&
-		cl->downloadCurrentBlock - cl->downloadClientBlock < MAX_DOWNLOAD_WINDOW) {
-
-		cl->downloadBlockSize[cl->downloadCurrentBlock % MAX_DOWNLOAD_WINDOW] = 0;
-		cl->downloadCurrentBlock++;
-
-		cl->downloadEOF = qtrue;  // We have added the EOF block
-	}
-
-	if (cl->downloadClientBlock == cl->downloadCurrentBlock)
-		return 0; // Nothing to transmit
-
-	// Write out the next section of the file, if we have already reached our window,
-	// automatically start retransmitting
-	if (cl->downloadXmitBlock == cl->downloadCurrentBlock)
-	{
-		// We have transmitted the complete window, should we start resending?
-		if (svs.time - cl->downloadSendTime > 1000)
-			cl->downloadXmitBlock = cl->downloadClientBlock;
-		else
-			return 0;
-	}
-
-	// Send current block
-	curindex = (cl->downloadXmitBlock % MAX_DOWNLOAD_WINDOW);
-
-	MSG_WriteByte( msg, svc_download );
-	MSG_WriteShort( msg, cl->downloadXmitBlock );
-
-	// block zero is special, contains file size
-	if ( cl->downloadXmitBlock == 0 )
-		MSG_WriteLong( msg, cl->downloadSize );
-
-	MSG_WriteShort( msg, cl->downloadBlockSize[curindex] );
-
-	// Write the block
-	if(cl->downloadBlockSize[curindex])
-		MSG_WriteData(msg, cl->downloadBlocks[curindex], cl->downloadBlockSize[curindex]);
-
-	Com_DPrintf( "clientDownload: %d : writing block %d\n", (int) (cl - svs.clients), cl->downloadXmitBlock );
-
-	// Move on to the next block
-	// It will get sent with next snap shot.  The rate will keep us in line.
-	cl->downloadXmitBlock++;
-	cl->downloadSendTime = svs.time;
-
 	return 1;
 }
 
@@ -1197,152 +1197,152 @@
 =================
 */
 static void SV_VerifyPaks_f( client_t *cl ) {
-	int nChkSum1, nChkSum2, nClientPaks, nServerPaks, i, j, nCurArg;
-	int nClientChkSum[1024];
-	int nServerChkSum[1024];
-	const char *pPaks, *pArg;
-	qboolean bGood = qtrue;
+	//int nChkSum1, nChkSum2, nClientPaks, nServerPaks, i, j, nCurArg;
+	//int nClientChkSum[1024];
+	//int nServerChkSum[1024];
+	//const char *pPaks, *pArg;
+	//qboolean bGood = qtrue;
 
-	// if we are pure, we "expect" the client to load certain things from 
-	// certain pk3 files, namely we want the client to have loaded the
-	// ui and cgame that we think should be loaded based on the pure setting
-	//
-	if ( sv_pure->integer != 0 ) {
+	//// if we are pure, we "expect" the client to load certain things from 
+	//// certain pk3 files, namely we want the client to have loaded the
+	//// ui and cgame that we think should be loaded based on the pure setting
+	////
+	//if ( sv_pure->integer != 0 ) {
 
-		nChkSum1 = nChkSum2 = 0;
-		// we run the game, so determine which cgame and ui the client "should" be running
-		bGood = (FS_FileIsInPAK("vm/cgame.qvm", &nChkSum1) == 1);
-		if (bGood)
-			bGood = (FS_FileIsInPAK("vm/ui.qvm", &nChkSum2) == 1);
+	//	nChkSum1 = nChkSum2 = 0;
+	//	// we run the game, so determine which cgame and ui the client "should" be running
+	//	bGood = (FS_FileIsInPAK("vm/cgame.qvm", &nChkSum1) == 1);
+	//	if (bGood)
+	//		bGood = (FS_FileIsInPAK("vm/ui.qvm", &nChkSum2) == 1);
 
-		nClientPaks = Cmd_Argc();
+	//	nClientPaks = Cmd_Argc();
 
-		// start at arg 2 ( skip serverId cl_paks )
-		nCurArg = 1;
+	//	// start at arg 2 ( skip serverId cl_paks )
+	//	nCurArg = 1;
 
-		pArg = Cmd_Argv(nCurArg++);
-		if(!pArg) {
-			bGood = qfalse;
-		}
-		else
-		{
-			// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=475
-			// we may get incoming cp sequences from a previous checksumFeed, which we need to ignore
-			// since serverId is a frame count, it always goes up
-			if (atoi(pArg) < sv.checksumFeedServerId)
-			{
-				Com_DPrintf("ignoring outdated cp command from client %s\n", cl->name);
-				return;
-			}
-		}
-	
-		// we basically use this while loop to avoid using 'goto' :)
-		while (bGood) {
+	//	pArg = Cmd_Argv(nCurArg++);
+	//	if(!pArg) {
+	//		bGood = qfalse;
+	//	}
+	//	else
+	//	{
+	//		// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=475
+	//		// we may get incoming cp sequences from a previous checksumFeed, which we need to ignore
+	//		// since serverId is a frame count, it always goes up
+	//		if (atoi(pArg) < sv.checksumFeedServerId)
+	//		{
+	//			Com_DPrintf("ignoring outdated cp command from client %s\n", cl->name);
+	//			return;
+	//		}
+	//	}
+	//
+	//	// we basically use this while loop to avoid using 'goto' :)
+	//	while (bGood) {
 
-			// must be at least 6: "cl_paks cgame ui @ firstref ... numChecksums"
-			// numChecksums is encoded
-			if (nClientPaks < 6) {
-				bGood = qfalse;
-				break;
-			}
-			// verify first to be the cgame checksum
-			pArg = Cmd_Argv(nCurArg++);
-			if (!pArg || *pArg == '@' || atoi(pArg) != nChkSum1 ) {
-				bGood = qfalse;
-				break;
-			}
-			// verify the second to be the ui checksum
-			pArg = Cmd_Argv(nCurArg++);
-			if (!pArg || *pArg == '@' || atoi(pArg) != nChkSum2 ) {
-				bGood = qfalse;
-				break;
-			}
-			// should be sitting at the delimeter now
-			pArg = Cmd_Argv(nCurArg++);
-			if (*pArg != '@') {
-				bGood = qfalse;
-				break;
-			}
-			// store checksums since tokenization is not re-entrant
-			for (i = 0; nCurArg < nClientPaks; i++) {
-				nClientChkSum[i] = atoi(Cmd_Argv(nCurArg++));
-			}
+	//		// must be at least 6: "cl_paks cgame ui @ firstref ... numChecksums"
+	//		// numChecksums is encoded
+	//		if (nClientPaks < 6) {
+	//			bGood = qfalse;
+	//			break;
+	//		}
+	//		// verify first to be the cgame checksum
+	//		pArg = Cmd_Argv(nCurArg++);
+	//		if (!pArg || *pArg == '@' || atoi(pArg) != nChkSum1 ) {
+	//			bGood = qfalse;
+	//			break;
+	//		}
+	//		// verify the second to be the ui checksum
+	//		pArg = Cmd_Argv(nCurArg++);
+	//		if (!pArg || *pArg == '@' || atoi(pArg) != nChkSum2 ) {
+	//			bGood = qfalse;
+	//			break;
+	//		}
+	//		// should be sitting at the delimeter now
+	//		pArg = Cmd_Argv(nCurArg++);
+	//		if (*pArg != '@') {
+	//			bGood = qfalse;
+	//			break;
+	//		}
+	//		// store checksums since tokenization is not re-entrant
+	//		for (i = 0; nCurArg < nClientPaks; i++) {
+	//			nClientChkSum[i] = atoi(Cmd_Argv(nCurArg++));
+	//		}
 
-			// store number to compare against (minus one cause the last is the number of checksums)
-			nClientPaks = i - 1;
+	//		// store number to compare against (minus one cause the last is the number of checksums)
+	//		nClientPaks = i - 1;
 
-			// make sure none of the client check sums are the same
-			// so the client can't send 5 the same checksums
-			for (i = 0; i < nClientPaks; i++) {
-				for (j = 0; j < nClientPaks; j++) {
-					if (i == j)
-						continue;
-					if (nClientChkSum[i] == nClientChkSum[j]) {
-						bGood = qfalse;
-						break;
-					}
-				}
-				if (bGood == qfalse)
-					break;
-			}
-			if (bGood == qfalse)
-				break;
+	//		// make sure none of the client check sums are the same
+	//		// so the client can't send 5 the same checksums
+	//		for (i = 0; i < nClientPaks; i++) {
+	//			for (j = 0; j < nClientPaks; j++) {
+	//				if (i == j)
+	//					continue;
+	//				if (nClientChkSum[i] == nClientChkSum[j]) {
+	//					bGood = qfalse;
+	//					break;
+	//				}
+	//			}
+	//			if (bGood == qfalse)
+	//				break;
+	//		}
+	//		if (bGood == qfalse)
+	//			break;
 
-			// get the pure checksums of the pk3 files loaded by the server
-			pPaks = FS_LoadedPakPureChecksums();
-			Cmd_TokenizeString( pPaks );
-			nServerPaks = Cmd_Argc();
-			if (nServerPaks > 1024)
-				nServerPaks = 1024;
+	//		// get the pure checksums of the pk3 files loaded by the server
+	//		pPaks = FS_LoadedPakPureChecksums();
+	//		Cmd_TokenizeString( pPaks );
+	//		nServerPaks = Cmd_Argc();
+	//		if (nServerPaks > 1024)
+	//			nServerPaks = 1024;
 
-			for (i = 0; i < nServerPaks; i++) {
-				nServerChkSum[i] = atoi(Cmd_Argv(i));
-			}
+	//		for (i = 0; i < nServerPaks; i++) {
+	//			nServerChkSum[i] = atoi(Cmd_Argv(i));
+	//		}
 
-			// check if the client has provided any pure checksums of pk3 files not loaded by the server
-			for (i = 0; i < nClientPaks; i++) {
-				for (j = 0; j < nServerPaks; j++) {
-					if (nClientChkSum[i] == nServerChkSum[j]) {
-						break;
-					}
-				}
-				if (j >= nServerPaks) {
-					bGood = qfalse;
-					break;
-				}
-			}
-			if ( bGood == qfalse ) {
-				break;
-			}
+	//		// check if the client has provided any pure checksums of pk3 files not loaded by the server
+	//		for (i = 0; i < nClientPaks; i++) {
+	//			for (j = 0; j < nServerPaks; j++) {
+	//				if (nClientChkSum[i] == nServerChkSum[j]) {
+	//					break;
+	//				}
+	//			}
+	//			if (j >= nServerPaks) {
+	//				bGood = qfalse;
+	//				break;
+	//			}
+	//		}
+	//		if ( bGood == qfalse ) {
+	//			break;
+	//		}
 
-			// check if the number of checksums was correct
-			nChkSum1 = sv.checksumFeed;
-			for (i = 0; i < nClientPaks; i++) {
-				nChkSum1 ^= nClientChkSum[i];
-			}
-			nChkSum1 ^= nClientPaks;
-			if (nChkSum1 != nClientChkSum[nClientPaks]) {
-				bGood = qfalse;
-				break;
-			}
+	//		// check if the number of checksums was correct
+	//		nChkSum1 = sv.checksumFeed;
+	//		for (i = 0; i < nClientPaks; i++) {
+	//			nChkSum1 ^= nClientChkSum[i];
+	//		}
+	//		nChkSum1 ^= nClientPaks;
+	//		if (nChkSum1 != nClientChkSum[nClientPaks]) {
+	//			bGood = qfalse;
+	//			break;
+	//		}
 
-			// break out
-			break;
-		}
+	//		// break out
+	//		break;
+	//	}
 
-		cl->gotCP = qtrue;
+	//	cl->gotCP = qtrue;
 
-		if (bGood) {
-			cl->pureAuthentic = 1;
-		} 
-		else {
-			cl->pureAuthentic = 0;
-			cl->lastSnapshotTime = 0;
-			cl->state = CS_ACTIVE;
-			SV_SendClientSnapshot( cl );
-			SV_DropClient( cl, "Unpure client detected. Invalid .PK3 files referenced!" );
-		}
-	}
+	//	if (bGood) {
+	//		cl->pureAuthentic = 1;
+	//	} 
+	//	else {
+	//		cl->pureAuthentic = 0;
+	//		cl->lastSnapshotTime = 0;
+	//		cl->state = CS_ACTIVE;
+	//		SV_SendClientSnapshot( cl );
+	//		SV_DropClient( cl, "Unpure client detected. Invalid .PK3 files referenced!" );
+	//	}
+	//}
 }
 
 /*
Index: code/server/sv_init.cpp
===================================================================
--- code/server/sv_init.cpp	(revision 291)
+++ code/server/sv_init.cpp	(working copy)
@@ -388,24 +388,7 @@
 	Com_Memset (&sv, 0, sizeof(sv));
 }
 
-/*
-================
-SV_TouchCGame
 
-  touch the cgame.vm so that a pure client can load it if it's in a seperate pk3
-================
-*/
-static void SV_TouchCGame(void) {
-	fileHandle_t	f;
-	char filename[MAX_QPATH];
-
-	Com_sprintf( filename, sizeof(filename), "vm/%s.qvm", "cgame" );
-	FS_FOpenFileRead( filename, &f, qfalse );
-	if ( f ) {
-		FS_FCloseFile( f );
-	}
-}
-
 #include "sv_vis.h"
 #include <shared/portalizedBSPTree.h> 
 #include <shared/doom3ProcPVSClass.h> 
@@ -508,7 +491,7 @@
 	}
 
 	// clear pak references
-	FS_ClearPakReferences(0);
+//	FS_ClearPakReferences(0);
 
 	// allocate the snapshot entities on the hunk
 	svs.snapshotEntities = (entityState_s*)Hunk_Alloc( sizeof(entityState_s)*svs.numSnapshotEntities, h_high );
@@ -541,7 +524,7 @@
 
 	// get a new checksum feed and restart the file system
 	sv.checksumFeed = ( ((int) rand() << 16) ^ rand() ) ^ Com_Milliseconds();
-	FS_Restart( sv.checksumFeed );
+//	FS_Restart( sv.checksumFeed );
 
 	// load map visibility data used to cull entities unreachable by player on the serverside
 	// This saves a lot of bandwith on large indoor maps compiled with PVS
@@ -638,32 +621,33 @@
 	sv.time += 100;
 	svs.time += 100;
 
-	if ( sv_pure->integer ) {
-		// the server sends these to the clients so they will only
-		// load pk3s also loaded at the server
-		p = FS_LoadedPakChecksums();
-		Cvar_Set( "sv_paks", p );
-		if (strlen(p) == 0) {
-			Com_Printf( "WARNING: sv_pure set but no PK3 files loaded\n" );
-		}
-		p = FS_LoadedPakNames();
-		Cvar_Set( "sv_pakNames", p );
+	//if ( sv_pure->integer ) {
+	//	// the server sends these to the clients so they will only
+	//	// load pk3s also loaded at the server
+	//	p = FS_LoadedPakChecksums();
+	//	Cvar_Set( "sv_paks", p );
+	//	if (strlen(p) == 0) {
+	//		Com_Printf( "WARNING: sv_pure set but no PK3 files loaded\n" );
+	//	}
+	//	p = FS_LoadedPakNames();
+	//	Cvar_Set( "sv_pakNames", p );
 
-		// if a dedicated pure server we need to touch the cgame because it could be in a
-		// seperate pk3 file and the client will need to load the latest cgame.qvm
-		if ( com_dedicated->integer ) {
-			SV_TouchCGame();
-		}
-	}
-	else {
+	//	// if a dedicated pure server we need to touch the cgame because it could be in a
+	//	// seperate pk3 file and the client will need to load the latest cgame.qvm
+	//	if ( com_dedicated->integer ) {
+	//		SV_TouchCGame();
+	//	}
+	//}
+	//else 
+	{
 		Cvar_Set( "sv_paks", "" );
 		Cvar_Set( "sv_pakNames", "" );
 	}
 	// the server sends these to the clients so they can figure
 	// out which pk3s should be auto-downloaded
-	p = FS_ReferencedPakChecksums();
+	p = "";//FS_ReferencedPakChecksums();
 	Cvar_Set( "sv_referencedPaks", p );
-	p = FS_ReferencedPakNames();
+	p = "";//FS_ReferencedPakNames();
 	Cvar_Set( "sv_referencedPakNames", p );
 
 	// save systeminfo and serverinfo strings
Index: code/server/sv_vis.cpp
===================================================================
--- code/server/sv_vis.cpp	(revision 283)
+++ code/server/sv_vis.cpp	(working copy)
@@ -105,7 +105,7 @@
 }
 bool svBSP_c::load(const char *fname) {
 	byte *fileData = 0;
-	u32 fileLen = g_vfs->FS_ReadFile(fname,(void**)&fileData);
+	u32 fileLen = g_vfs->loadFileData(fname,&fileData);
 	if(fileData == 0) {
 		g_core->Print(S_COLOR_RED "svBSP_c::load: cannot open %s\n",fname);
 		return true;
@@ -113,35 +113,35 @@
 	h = (const q3Header_s*) fileData;
 	if(h->ident == BSP_IDENT_IBSP && (h->version == BSP_VERSION_Q3 || h->version == BSP_VERSION_ET)) {
 		if(loadNodesAndLeaves(Q3_NODES,Q3_LEAVES,sizeof(q3Leaf_s))) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadPlanes(Q3_PLANES)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadVisibility(Q3_VISIBILITY)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 	} else if(h->ident == BSP_IDENT_2015|| h->ident == BSP_IDENT_EALA) {
 		if(loadNodesAndLeaves(MOH_NODES,MOH_LEAVES,sizeof(q3Leaf_s)+16)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadPlanes(MOH_PLANES)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 		if(loadVisibility(MOH_VISIBILITY)) {
-			g_vfs->FS_FreeFile(fileData);
+			g_vfs->freeFileData(&fileData);
 			return true; // error
 		}
 	} else {
-		g_vfs->FS_FreeFile(fileData);
+		g_vfs->freeFileData(&fileData);
 		return true; // error
 	}
-	g_vfs->FS_FreeFile(fileData);
+	g_vfs->freeFileData(&fileData);
 	h = 0; // pointer to header is no longer valid
 	return false; // no error
 }
Index: code/shared/bspPhysicsDataLoader.cpp
===================================================================
--- code/shared/bspPhysicsDataLoader.cpp	(revision 292)
+++ code/shared/bspPhysicsDataLoader.cpp	(working copy)
@@ -45,21 +45,22 @@
 	}
 }
 bool bspPhysicsDataLoader_c::loadBSPFile(const char *fname) {
-	fileHandle_t f;
-	int len = g_vfs->FS_FOpenFile(fname,&f,FS_READ);
-	if(len < 0) {
+	vfsFileAPI_i *f;
+	f = g_vfs->openFile(fname,"r");
+	if(f == 0) {
 		char buf[256];
 		strcpy(buf,"maps/");
 		strcat(buf,fname);
 		strcat(buf,".bsp");
-		len = g_vfs->FS_FOpenFile(buf,&f,FS_READ);
-		if(len < 0) {
+		f = g_vfs->openFile(buf,"r");
+		if(f == 0) {
 			return true; // error
 		}
 	}
+	u32 len = f->getTotalLen();
 	byte *data = (byte*)malloc(len);
-	g_vfs->FS_Read(data,len,f);
-	g_vfs->FS_FCloseFile(f);
+	f->readData(data,len);
+	g_vfs->closeFile(f);
 	h = (q3Header_s*)data;
 	// see if the bsp file format is supported
 	if(h->isKnownBSPHeader() == false) {
Index: code/shared/bspPhysicsDataLoader.h
===================================================================
--- code/shared/bspPhysicsDataLoader.h	(revision 280)
+++ code/shared/bspPhysicsDataLoader.h	(working copy)
@@ -31,6 +31,7 @@
 #include "array.h"
 
 class bspPhysicsDataLoader_c {
+	byte *fileData;
 	struct q3Header_s *h;
 
 	u32 getMaterialContentFlags(u32 matNum) const;
Index: code/shared/cStylePreprocessor.cpp
===================================================================
--- code/shared/cStylePreprocessor.cpp	(revision 274)
+++ code/shared/cStylePreprocessor.cpp	(working copy)
@@ -28,7 +28,7 @@
 
 bool cStylePreprocessor_c::preprocessFile(const char *fname) {
 	byte *fileData = 0;
-	u32 fileLen = g_vfs->FS_ReadFile(fname,(void**)&fileData);
+	u32 fileLen = g_vfs->loadFileData(fname,&fileData);
 	if(fileData == 0) {
 		return true; // error
 	}
Index: code/shared/entDefsList.cpp
===================================================================
--- code/shared/entDefsList.cpp	(revision 292)
+++ code/shared/entDefsList.cpp	(working copy)
@@ -95,14 +95,11 @@
 	strcpy(buf,"maps/");
 	strcat(buf,mapName);
 	strcat(buf,".bsp");
-	fileHandle_t f;
-	int len = g_vfs->FS_FOpenFile(buf,&f,FS_READ);
-	if(f == 0) {
+	byte *data;
+	u32 len = g_vfs->loadFileData(buf,&data);
+	if(data == 0) {
 		return true;
 	}
-	byte *data = (byte*)malloc(len);
-	g_vfs->FS_Read(data,len,f);
-	g_vfs->FS_FCloseFile(f);
 
 	const char *text;
 
@@ -118,11 +115,11 @@
 	} else {
 		g_core->Print(S_COLOR_RED"entDefsList_c::load: unknown bsp type\n");
 		text = 0;
-		free(data);
+		g_vfs->freeFileData(&data);
 		return true; // error
 	}
 	bool error = this->fromString(text);
-	free(data);
+	g_vfs->freeFileData(&data);
 	return error;
 }
 bool entDefsList_c::loadEntitiesFromMapFile(const char *mapName) {
@@ -130,17 +127,14 @@
 	strcpy(buf,"maps/");
 	strcat(buf,mapName);
 	strcat(buf,".map");
-	fileHandle_t f;
-	int len = g_vfs->FS_FOpenFile(buf,&f,FS_READ);
-	if(f == 0) {
+	byte *data;
+	u32 len = g_vfs->loadFileData(buf,&data);
+	if(data == 0) {
 		return true;
 	}
-	byte *data = (byte*)malloc(len);
-	g_vfs->FS_Read(data,len,f);
-	g_vfs->FS_FCloseFile(f);
 	const char *text = (const char*)data;
 	bool error = this->fromString(text);
-	free(data);
+	g_vfs->freeFileData(&data);
 	return error;
 }
 bool entDefsList_c::loadEntitiesFromEntitiesFile(const char *mapName) {
Index: code/shared/fileStreamHelper.cpp
===================================================================
--- code/shared/fileStreamHelper.cpp	(revision 183)
+++ code/shared/fileStreamHelper.cpp	(working copy)
@@ -34,12 +34,12 @@
 }
 void fileStreamHelper_c::clear() {
 	if(handle) {
-		g_vfs->FS_FCloseFile(handle);
+		g_vfs->closeFile(handle);
 		handle = 0;
 	}
 }
 bool fileStreamHelper_c::beginWriting(const char *fname) {
-	int res = g_vfs->FS_FOpenFile(fname,&handle,FS_WRITE);
+	handle = g_vfs->openFile(fname,"w");
 	if(handle == 0)
 		return true;
 	return false;
@@ -55,5 +55,5 @@
 	
 	u32 len = strlen(msg);
 
-	g_vfs->FS_Write(msg, len, handle);
+	handle->writeData(msg, len);
 }
\ No newline at end of file
Index: code/shared/fileStreamHelper.h
===================================================================
--- code/shared/fileStreamHelper.h	(revision 183)
+++ code/shared/fileStreamHelper.h	(working copy)
@@ -28,7 +28,7 @@
 #include <api/writeStreamAPI.h>
 
 class fileStreamHelper_c : public writeStreamAPI_i {
-	int handle;
+	class vfsFileAPI_i *handle;
 public:
 	fileStreamHelper_c();
 	~fileStreamHelper_c();
Index: code/shared/parser.cpp
===================================================================
--- code/shared/parser.cpp	(revision 292)
+++ code/shared/parser.cpp	(working copy)
@@ -36,12 +36,12 @@
 
 void parser_c::clear() {
 	if(fileData) {
-		g_vfs->FS_FreeFile(fileData);
+		g_vfs->freeFileData((byte**)&fileData);
 	}
 }
 bool parser_c::openFile(const char *fname) {
 	this->clear();
-	int len = g_vfs->FS_ReadFile(fname,(void**)&fileData);
+	u32 len = g_vfs->loadFileData(fname,(byte**)&fileData);
 	if(fileData == 0) {
 		return true; // cannot open
 	}
Index: code/shared/readStream.cpp
===================================================================
--- code/shared/readStream.cpp	(revision 296)
+++ code/shared/readStream.cpp	(working copy)
@@ -27,8 +27,23 @@
 #include <api/vfsAPI.h>
 #include <shared/str.h>
 
+readStream_c::readStream_c() {
+	streamLen = 0;
+	fileData = 0;
+	data = 0;
+	ofs = 0;
+}
+readStream_c::~readStream_c() {
+	clear();
+}
+void readStream_c::clear() {
+	if(fileData) {
+		g_vfs->freeFileData(&fileData);
+	}
+	data = 0;
+}
 bool readStream_c::loadFromFile(const char *fname) {
-	streamLen = g_vfs->FS_ReadFile(fname,&fileData);
+	streamLen = g_vfs->loadFileData(fname,&fileData);
 	if(fileData == 0) {
 		return true; // failed to open file
 	}
Index: code/shared/readStream.h
===================================================================
--- code/shared/readStream.h	(revision 296)
+++ code/shared/readStream.h	(working copy)
@@ -28,13 +28,18 @@
 #include <api/readStreamAPI.h>
 
 class readStream_c : public readStreamAPI_i {
-	long streamLen;
-	void *fileData;
+	u32 streamLen;
+	byte *fileData;
 	byte *data;
 	u32 ofs;
 public:
 	bool loadFromFile(const char *fname);
 
+	readStream_c();
+	~readStream_c();
+
+	void clear();
+
 	virtual bool isAtEOF() const;
 	virtual u32 readData(void *out, u32 numBytes);
 	virtual bool isAtData(const void *out, u32 numBytes);
Index: code/tools/q3radiant/libs/cmdlib.lib
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: code/tools/q3radiant/libs/jpeg6.lib
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: code/tools/q3radiant/libs/pak.lib
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: misc/msvc/ioq3.sln
===================================================================
--- misc/msvc/ioq3.sln	(revision 240)
+++ misc/msvc/ioq3.sln	(working copy)
@@ -32,6 +32,8 @@
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "backendDX10", "backendDX10.vcproj", "{C04471A6-13A6-418B-8D96-A4929C67FAA8}"
 EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "vfs", "vfs.vcproj", "{ACD5B8D6-3BC8-41BB-8BA9-42627C3CAF9E}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Win32 = Debug|Win32
@@ -102,6 +104,10 @@
 		{C04471A6-13A6-418B-8D96-A4929C67FAA8}.Debug|Win32.Build.0 = Debug|Win32
 		{C04471A6-13A6-418B-8D96-A4929C67FAA8}.Release|Win32.ActiveCfg = Release|Win32
 		{C04471A6-13A6-418B-8D96-A4929C67FAA8}.Release|Win32.Build.0 = Release|Win32
+		{ACD5B8D6-3BC8-41BB-8BA9-42627C3CAF9E}.Debug|Win32.ActiveCfg = Debug|Win32
+		{ACD5B8D6-3BC8-41BB-8BA9-42627C3CAF9E}.Debug|Win32.Build.0 = Debug|Win32
+		{ACD5B8D6-3BC8-41BB-8BA9-42627C3CAF9E}.Release|Win32.ActiveCfg = Release|Win32
+		{ACD5B8D6-3BC8-41BB-8BA9-42627C3CAF9E}.Release|Win32.Build.0 = Release|Win32
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
